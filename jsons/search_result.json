{
"err_no": 0,
"err_msg": "success",
"data": [
{
"article_info": {
"title": "【flutter】mac安装flutter",
"author_id": 1000013586,
"comment_count": 1,
"content": "### mac安装flutter\n\n#### 一、下载flutter\n##### 1、第一种方式git repo方式\n执行下列命令下载最新的flutter代码（系统请先安装Git）\n```git\ngit clone -b beta https://github.com/flutter/flutter.git\n```\n\n##### 2、第二种方式官方网站\nflutter官网下载其最新可用的安装包，转到[下载页](https://flutter.dev/docs/get-started/install)。\n\n\n#### 二、安装flutter，环境配置，依赖项检查\n（1）目前接下来我的是使用官方网下载的zip压缩包。\n\n（2）解压\n\n（3）添加flutter相关工具到path中：\n```bash\nexport PATH=`pwd`/flutter/bin:$PATH\n```\n这个命令只在当前命令行中设置PATH环境变量，要想永久将Flutter添加到PATH中请参考下面更新环境变量部分。\n\n使用命令查看是否安装成功\n```bash\n./bin/flutter --v\n```\n[检查flutter是否安装成功](http://static.chengxinsong.cn/image/flutter/flutter-1.jpg)\n\n（4）个人觉得还是使用永久的将flutter添加到path中\n\n在用户文件夹下找到.bash_profile文件，如果没有就创建一个;\n\n```text\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn \nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn \nexport PATH=/Users/chengxinsong/Desktop/Tool/flutter/bin:$PATH\n```\n添加保存后，执行下列命令刷新终端：\n```\nsource $HOME/.bash_profile\n```\n运行下列命令检查flutter是否已经安装成功：\n```bash\nflutter -v\n```\n[检查flutter是否安装成功](http://static.chengxinsong.cn/image/flutter/flutter-2.jpg)\n\n出现上述说明，安装成功。\n\n（6）检查flutter的依赖项\n```bash\nflutter doctor\n```\nflutter会提示你那些东西是必须要的，需要执行什么命令进行安装，按照提示安装即可；\n[检查flutter的依赖性](http://static.chengxinsong.cn/image/flutter/flutter-3.jpg)\n\n\n#### 三、第一个Flutter App\n打开VsCode\n\nVsCode需要安装两个扩展：Dart和Flutter。\n\n按F1(有touchbar的机子按住fn可见F1)呼出命令输入框；\n\n输入字符Flutter，在命令候选列表中选择Flutter: New Project，\n新建一个Flutter项目，随后让你填写项目名称和选择项目存放路径；\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-5.jpg)\n\n设置好flutter的安装路径的根目录。\n\n项目创建好后，在VSCode右下角选择调试环境目标:\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-6.jpg)\n\n怎么启动?vscode已经提示f5启动项目。启动有点慢，等着就好了。\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-7.jpg)\n\n点击+号\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-8.jpg)\n\n",
"ctime": 1589291815,
"mtime": 1622627886,
"commentable": 0,
"status": 0,
"dig_cnt": 1,
"collect_cnt": 0,
"cover_url": "https://tech-proxy.bytedance.net/tos/images/1589291811552_9bbab4ed0216d313ad84a392b411e00c.jpg",
"brief": "",
"article_id": "6825887293841096711",
"draft_id": "6825955901967433741",
"view_cnt": 127,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "\\[Flutter] Mac install flutter\n",
"en_content": "### Mac install flutter\n\n#### Download flutter\n\n##### 1, the first way git repo way\n\nExecute the following command to download the latest flutter code (please install Git first)\n\n```git\ngit clone -b beta https://github.com/flutter/flutter.git\n```\n\n##### The second way official website\n\nDownload the latest available installation package on the flutter website, go to[Download page](https://flutter.dev/docs/get-started/install)。\n\n#### Install flutter, environment configuration, dependency check\n\n(1) At present, I am using the zip compression package downloaded from the official website.\n\n(2) decompression\n\n(3) Add flutter related tools to the path:\n\n```bash\nexport PATH=`pwd`/flutter/bin:$PATH\n```\n\nThis command only sets PATH environment variables in the current command line. To permanently add Flutter to PATH, please refer to the Update Environment Variables section below.\n\nUse the command to see if the installation is successful\n\n```bash\n./bin/flutter --v\n```\n\n[Check whether flutter is installed successfully](http://static.chengxinsong.cn/image/flutter/flutter-1.jpg)\n\n(4) Personally, I think I still use permanent flutter to add to the path\n\nFind the bash_profile file under the user folder, and create one if there is none;\n\n```text\nexport PUB_HOSTED_URL=https://pub.flutter-io.cn \nexport FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn \nexport PATH=/Users/chengxinsong/Desktop/Tool/flutter/bin:$PATH\n```\n\nAfter adding the save, execute the following command to refresh the terminal:\n\n    source $HOME/.bash_profile\n\nRun the following command to check that flutter has been installed successfully:\n\n```bash\nflutter -v\n```\n\n[Check whether flutter is installed successfully](http://static.chengxinsong.cn/image/flutter/flutter-2.jpg)\n\nThe above instructions appear and the installation is successful.\n\n(6) Check the dependencies of flutter\n\n```bash\nflutter doctor\n```\n\nFlutter will prompt you that those things are necessary, what commands need to be executed to install, just follow the prompts to install;\n[Check flutter dependency](http://static.chengxinsong.cn/image/flutter/flutter-3.jpg)\n\n#### The first Flutter App\n\nOpen VsCode\n\nVsCode requires two extensions to be installed: Dart and Flutter.\n\nPress F1 (F1 can be seen when the machine with touchbar presses and holds fn) to enter the outgoing command box;\n\nEnter the character Flutter, select Flutter: New Project from the command candidate list,\nCreate a new Flutter project, then let you fill in the project name and select the project storage path;\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-5.jpg)\n\nSet the root directory of the flutter installation path.\n\nAfter the project is created, select the debug environment target in the lower right corner of VSCode:\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-6.jpg)\n\nHow to start? Vscode has prompted f5 to start the project. Start a little slow, just wait.\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-7.jpg)\n\nClick + sign\n\n![flutter](http://static.chengxinsong.cn/image/flutter/flutter-8.jpg)\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "程新松",
"full_name": "程新松",
"email": "chengxinsong@bytedance.com",
"employee_id": 1000013586,
"lark_id": "6746382553587908877",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/27b1293b-83ed-44ab-ac12-8eb1228f4acg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 6,
"follower_count": 44,
"digg_cnt": 169,
"lark_open_id": "714fgfae",
"auth": 0,
"department_name": "Data-数据平台-前端-增长平台",
"intro": "STAY CURIOUS. STAY HUMBLE.",
"roleIds": [],
"score": 214,
"status": 1,
"answer_digg_cnt": 10,
"question_cnt": 0,
"answer_cnt": 1,
"is_follow": false,
"collect_cnt": 111,
"xid": "469d1ff5e6209e785e26cf0a1001621a",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 1,
"Hackathon": 1,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000065000198",
"name": "Data-数据平台-前端-增长平台",
"en_name": "Data-Data Platform-Front End-Growth Platform"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Xinsong Cheng",
"leader": {
"id": 9698995,
"name": "陈屹",
"u_name": "陈屹 (chenyi.arthur)",
"email": "chenyi.arthur@bytedance.com",
"employee_number": 9698995,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 3230538,
"entry_date": 1570752000
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "/bin/<em>flutter</em> --v\n```\n[检查<em>flutter</em>是否安装成功](http://static.chengxinsong.cn/image/<em>flutter</em>/<em>flutter</em>-1.jpg)\n\n（4...[<em>flutter</em>](http://static.chengxinsong.cn/image/<em>flutter</em>/<em>flutter</em>-5.jpg)\n\n设置好<em>flutter</em>的安装路径的根目录。"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"app_info": {
"id": 853,
"app_id": "169",
"title": "Flutter",
"brief": "媲美原生的高性能跨平台技术方案，沉淀大量的技术分享",
"description": "公司级的Flutter引擎--bd_flutter，集众多优化与黑科技一体：\n\n- 基础设施：开发更高效、便捷\n- 应用框架：基础库更丰富、可靠\n- 引擎框架：性能更优、跨端更强大\n",
"author_id": 1000008607,
"ctime": 1567500056,
"mtime": 1622800214,
"url": "http://flutter.bytedance.net/",
"origin_type": 0,
"origin_id": "169",
"lark_group_open_id": "",
"logo_url": "https://tech-proxy.bytedance.net/tos/1567499990784336088x10.156.24.157.png",
"status": 0,
"digg_cnt": 0,
"view_cnt": 474,
"collect_cnt": 4,
"comment_cnt": 0,
"point_score": 0,
"docs": {
"wikis": [
{
"name": "文档地址",
"url": "http://flutter.bytedance.net/"
}
],
"codes": []
}
},
"auther": {
"name": "袁辉辉",
"full_name": "袁辉辉",
"email": "yuanhuihui@bytedance.com",
"employee_id": 1000008607,
"lark_id": "6687750276985651469",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da730014af521a367fed~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 71,
"digg_cnt": 199,
"lark_open_id": "c17e7gb9",
"auth": 1,
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"intro": "Gityuan",
"roleIds": [
1
],
"score": 358,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 65,
"xid": "7783babcb9a649cb74e823d99fa102b1",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Huihui Yuan",
"leader": {
"id": 7937698,
"name": "朱元硕",
"u_name": "朱元硕 (zhuyuanshuo)",
"email": "zhuyuanshuo@bytedance.com",
"employee_number": 7937698,
"en_name": ""
},
"expert_category_ids": [
3
],
"people_id": 9761123,
"entry_date": 1557100800
},
"owners": [
{
"name": "袁辉辉",
"full_name": "袁辉辉",
"email": "yuanhuihui@bytedance.com",
"employee_id": 1000008607,
"lark_id": "6687750276985651469",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da730014af521a367fed~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 71,
"digg_cnt": 199,
"lark_open_id": "c17e7gb9",
"auth": 1,
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"intro": "Gityuan",
"roleIds": [
1
],
"score": 358,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 65,
"xid": "7783babcb9a649cb74e823d99fa102b1",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Huihui Yuan",
"leader": {
"id": 7937698,
"name": "朱元硕",
"u_name": "朱元硕 (zhuyuanshuo)",
"email": "zhuyuanshuo@bytedance.com",
"employee_number": 7937698,
"en_name": ""
},
"expert_category_ids": [
3
],
"people_id": 9761123,
"entry_date": 1557100800
}
],
"labels": [
{
"id": 101,
"name": "架构",
"follow_count": 72,
"item_count": 75,
"en_name": "Architecture",
"icon": "",
"is_follow": false
},
{
"id": 339,
"name": "跨平台",
"follow_count": 3,
"item_count": 16,
"en_name": "Cross-platform",
"icon": "",
"is_follow": false
},
{
"id": 712,
"name": "客户端",
"follow_count": 31,
"item_count": 71,
"en_name": "Client",
"icon": "",
"is_follow": false
},
{
"id": 799,
"name": "前端",
"follow_count": 53,
"item_count": 141,
"en_name": "Frontend",
"icon": "",
"is_follow": false
},
{
"id": 1032,
"name": "中台服务",
"follow_count": 52,
"item_count": 61,
"en_name": "Mid-platform service",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"toutiao_apps": [],
"lark_group_info": null,
"highlight": {
"content": "公司级的<em>Flutter</em>引擎--bd_<em>flutter</em>，集众多优化与黑科技一体：\n\n- 基础设施：开发更高效、便捷\n- 应用框架：基础库更丰富、可靠\n- 引擎框架：性能更优、跨端更强大"
},
"is_digg": false,
"is_collect": false,
"id_type": 9
},
{
"app_info": {
"id": 1312,
"app_id": "6931296152260526094",
"title": "UME",
"brief": "Flutter 应用内调试工具",
"description": "[UME](https://code.byted.org/video_flutter/xg_ume) (读音：油米~ or You & me) 是一个 Flutter 调试工具包，内置 10 多个通用插件（可自行扩展），无论是设计师、产品经理、研发或质量工程师，都能从中获取有用信息，从而提升整个团队的研发、验收、调试效率，这样的体验对于 Flutter 开发者来说是前所未有的。\n\n\n-   [UME Roadmap(2021)](https://bytedance.feishu.cn/docs/doccndU1hgEhfoAQRZJmg1Xk6Uh)\n-   常见问题及异常：[UME FAQ](https://bytedance.feishu.cn/docs/doccn028UkLOfwL0Ht9KmZhGnOg)\n-   一期使用文档 [UME一期](https://bytedance.feishu.cn/docs/doccnSFCpyxMsMx1Vts8eBINaEc#yweziv)\n-   二期使用文档 [UME 二期](https://bytedance.feishu.cn/docs/doccn0TJEwBnwIMpqXguW0yAyhf#)\n\n\n## 目前功能\n\n> -   其中 5 项功能依赖于 hook，需要工具链支持。\n> -   自 UME 0.2.0 版本起，支持在 release 环境自动移除，该功能依赖于工具链 conditional import 支持。\n\n-   首页功能\n\n    -   支持拖拽排序\n    -   展示当前使用功能\n\n-   Widget 信息展示\n\n    -   widget 名称\n    -   widget 大小\n    -   widget 文件路径\n    -   widget 代码所在行\n\n-   Widget 层级\n\n    -   widget 构建链\n    -   支持 widget 搜索\n    -   widget 信息展示\n    -   renderObject 详细信息展示\n\n-   网络调试 [依赖hook]\n\n    -   支持所有基于 http 包的等网络请求抓取\n\n    -   数据支持结构化展示，长按可以复制到剪贴板\n\n    -   收藏请求，单独展示；清空非收藏列表\n\n    -   请求过滤与搜索（支持部分匹配、正则匹配）\n\n    -   请求导出 curl\n\n    -   持久化与导出 HAR\n\n    -   mock 响应内容\n\n        -   完整har文件映射\n        -   修改单个字段\n\n    -   结构化信息长按复制\n\n-   内存泄露 [依赖hook]\n\n    -   支持自动检测由route打开的页面\n    -   Widget、State、Route对象的内存泄漏检测\n\n-   内存查看\n\n    -   Dart vm 信息展示\n    -   当前Dart 内存使用情况\n    -   具体类信息所占用的空间跟数量\n    -   类属性和方法展示\n\n-   CPU模块\n\n    -   CPU详细信息展示\n    -   CPU使用率（iOS）\n    -   App内存和磁盘使用情况\n\n-   性能看板\n\n    -   GPU和UI FPS信息展示\n\n-   颜色吸管\n\n    -   颜色值获取\n    -   十六进制\n\n-   对齐标尺\n\n    -   widget 屏幕坐标展示\n    -   可自动吸附最近widget\n\n-   二维码\n\n    -   二维码生成\n\n-   Vessel [依赖hook]\n\n    -   Dart异常信息展示\n    -   VesselAPI信息展示\n\n-   Logger [依赖hook]\n\n    -   展示debugPrint函数输出日志\n    -   支持搜索\n\n-   Device Info\n\n    -   手机硬件信息展示\n\n-   HTTP Server\n\n    -   目前8080端口用于上传文件，用户可上传HAR文件，用于Mock请求\n    -   8888端口作为数据端口，目前用途是校验服务host、接收用户上传的文件\n    -   未来计划开放更多数据api，允许通过该服务读取UME中的数据\n\n-   Channel Monitor [依赖hook]\n\n    -   channel调用方法名称\n    -   请求参数\n    -   返回起始时间\n    -   返回结果\n    -   支持搜索\n\n-   CodePreview\n\n    -   显示当前页面代码\n",
"author_id": 1003160660,
"ctime": 1614081103,
"mtime": 1622548384,
"url": "https://bytedance.feishu.cn/docs/doccnv9Zx8Pv3MWtGMti9A37Llb",
"origin_type": 0,
"origin_id": "",
"lark_group_open_id": "oc_cc9dabbde27f2d30eb15f341f0e0ffcd",
"logo_url": "https://tech-proxy.bytedance.net/tos/images/1614080534604_d24291cad95bce2d7ebb83a1ba85f1ea.png",
"status": 0,
"digg_cnt": 1,
"view_cnt": 83,
"collect_cnt": 1,
"comment_cnt": 0,
"point_score": 0,
"docs": {
"wikis": [
{
"name": "UME",
"url": "https://bytedance.feishu.cn/docs/doccnv9Zx8Pv3MWtGMti9A37Llb"
},
{
"name": "UME FAQ",
"url": "https://bytedance.feishu.cn/wiki/wikcnMMMg8v1fENAqqD50FL43ad"
},
{
"name": "UME Roadmap(2021)",
"url": "https://bytedance.feishu.cn/wiki/wikcnsFIfxssjgxJUx5lNUkCg6U"
}
],
"codes": [
{
"name": "video_flutter/xg_ume",
"url": "https://code.byted.org/video_flutter/xg_ume"
}
]
}
},
"auther": {
"name": "赵瑞",
"full_name": "赵瑞",
"email": "zhaorui.dev@bytedance.com",
"employee_id": 1003160660,
"lark_id": "6828741871355838465",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/24bfb51c-3b76-495e-b19a-81b61e0bfefg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 1,
"lark_open_id": "c1522f95",
"auth": 0,
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"intro": "",
"roleIds": [],
"score": 20,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 1,
"xid": "a95cece5dd1943e159edb3e8049462fb",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Rui Zhao",
"leader": {
"id": 1672,
"name": "徐东",
"u_name": "徐东 (xudong)",
"email": "xudong@bytedance.com",
"employee_number": 1339291,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 7726271,
"entry_date": 1589932800
},
"owners": [
{
"name": "赵瑞",
"full_name": "赵瑞",
"email": "zhaorui.dev@bytedance.com",
"employee_id": 1003160660,
"lark_id": "6828741871355838465",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/24bfb51c-3b76-495e-b19a-81b61e0bfefg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 1,
"lark_open_id": "c1522f95",
"auth": 0,
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"intro": "",
"roleIds": [],
"score": 20,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 1,
"xid": "a95cece5dd1943e159edb3e8049462fb",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Rui Zhao",
"leader": {
"id": 1672,
"name": "徐东",
"u_name": "徐东 (xudong)",
"email": "xudong@bytedance.com",
"employee_number": 1339291,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 7726271,
"entry_date": 1589932800
}
],
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
},
{
"id": 339,
"name": "跨平台",
"follow_count": 3,
"item_count": 16,
"en_name": "Cross-platform",
"icon": "",
"is_follow": false
},
{
"id": 712,
"name": "客户端",
"follow_count": 31,
"item_count": 71,
"en_name": "Client",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"toutiao_apps": [
{
"id": 170,
"app_id": 32,
"app_name": "video_article",
"app_cn_name": "西瓜视频",
"status": 0,
"ctime": 1557210341,
"mtime": 1557210341
},
{
"id": 166,
"app_id": 1112,
"app_name": "live_stream",
"app_cn_name": "火山小视频",
"status": 0,
"ctime": 1557110211,
"mtime": 1557110211
},
{
"id": 172,
"app_id": 1691,
"app_name": "ailamp",
"app_cn_name": "大力移动端",
"status": 1,
"ctime": 1557732976,
"mtime": 1557732976
},
{
"id": 218,
"app_id": 1881,
"app_name": "stone_mall",
"app_cn_name": "stone商城",
"status": 1,
"ctime": 1563372583,
"mtime": 1563372583
}
],
"lark_group_info": null,
"highlight": {
"content": "[UME](https://code.byted.org/video_<em>flutter</em>/xg_ume) (读音：油米~ or You & me) 是一个 <em>Flutter</em> 调试工具包，内置 10 多个通用插件...（可自行扩展），无论是设计师、产品经理、研发或质量工程师，都能从中获取有用信息，从而提升整个团队的研发、验收、调试效率，这样的体验对于 <em>Flutter</em> 开发者来说是前所未有的。"
},
"is_digg": false,
"is_collect": false,
"id_type": 9
},
{
"item_set": {
"id": 19,
"item_id": "6897936454698483725",
"id_type": 39,
"title": "Flutter 专题课程",
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"status": 0,
"ctime": 1606051037,
"mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"tag": 1,
"item_list": [
{
"item_id": "6844026122951196680",
"id_type": 24
},
{
"item_id": "6844026125459390478",
"id_type": 24
},
{
"item_id": "6844026124440174606",
"id_type": 24
},
{
"item_id": "6844026123374821383",
"id_type": 24
},
{
"item_id": "6844026126080147463",
"id_type": 24
},
{
"item_id": "6844026124943491086",
"id_type": 24
},
{
"item_id": "6844026123941068807",
"id_type": 24
}
],
"content_mtime": 1622714447
},
"author": {
"name": "邓欣悦",
"full_name": "邓欣悦",
"email": "dengxinyue.crys@bytedance.com",
"employee_id": 1000766945,
"lark_id": "6811274171402682370",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/575e484e-4abe-4f7a-8fdb-88431c6b037g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 3,
"follower_count": 9,
"digg_cnt": 1326,
"lark_open_id": "524g74eb",
"auth": 2,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "",
"roleIds": [
2
],
"score": 5675,
"status": 1,
"answer_digg_cnt": 4,
"question_cnt": 1,
"answer_cnt": 5,
"is_follow": false,
"collect_cnt": 2422,
"xid": "f52ada9bf65a6ae316baba5392ed62a9",
"participate_time": 0,
"badge": {
"Activity": 2,
"ArticleAndVideo": 3,
"PointOfView": 2
},
"employee_type_v2": {
"id": 2,
"name": "实习",
"en_name": "Intern"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Xinyue Deng",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 7978951,
"entry_date": 1585872000
},
"owners": [
{
"name": "邓欣悦",
"full_name": "邓欣悦",
"email": "dengxinyue.crys@bytedance.com",
"employee_id": 1000766945,
"lark_id": "6811274171402682370",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/575e484e-4abe-4f7a-8fdb-88431c6b037g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 3,
"follower_count": 9,
"digg_cnt": 1326,
"lark_open_id": "524g74eb",
"auth": 2,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "",
"roleIds": [
2
],
"score": 5675,
"status": 1,
"answer_digg_cnt": 4,
"question_cnt": 1,
"answer_cnt": 5,
"is_follow": false,
"collect_cnt": 2422,
"xid": "f52ada9bf65a6ae316baba5392ed62a9",
"participate_time": 0,
"badge": {
"Activity": 2,
"ArticleAndVideo": 3,
"PointOfView": 2
},
"employee_type_v2": {
"id": 2,
"name": "实习",
"en_name": "Intern"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Xinyue Deng",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 7978951,
"entry_date": 1585872000
}
],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"highlight": {
"content": "<em>Flutter</em> 专题课程"
},
"item_list": [
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 0,
"answer_digg_cnt": 0,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/2b5e5889-90a9-4de0-a068-3a000b34a6bg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 26,
"department": {
"en_name": "Product RD and Infrastructure-FRealEstate-Client",
"id": "288980000064981427",
"name": "产品研发和工程架构部-幸福里-客户端"
},
"department_name": "产品研发和工程架构部-幸福里-客户端",
"digg_cnt": 52,
"email": "xieran.sai@bytedance.com",
"employee_id": 1000007224,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Ran Xie",
"entry_date": 1491350400,
"expert_category_ids": [],
"follow_count": 0,
"follower_count": 15,
"full_name": "谢然",
"intro": "超凡入圣",
"is_follow": false,
"lark_id": "6442596260489724173",
"lark_open_id": "2gg89a75",
"leader": {
"email": "zhengshitu@bytedance.com",
"employee_number": 5311320,
"en_name": "",
"id": 1925,
"name": "郑识途",
"u_name": "郑识途 (zhengshitu)"
},
"name": "谢然",
"participate_time": 0,
"people_id": 7537537,
"question_cnt": 0,
"roleIds": [],
"score": 693,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "5becc65b706e9a12d21521f86605f908"
}
],
"video_info": {
"collect_cnt": 380,
"comment_cnt": 7,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 26,
"doc": {
"name": "edit?usp=sharing",
"url": "https://docs.google.com/presentation/d/1arRqnl-eM1u7hdeDhYA6SiGbl9Js2bG8E06beK6hu9c/edit?usp=sharing"
},
"duration": 4759,
"id_type": 24,
"item_id": "6844026122951196680",
"mtime": 1621585470,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-快速入门实战",
"url": "v02313990000bnn272ij2bori1i4nkhg",
"video_status": 1,
"view_cnt": 1142
}
},
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 0,
"answer_digg_cnt": 0,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da5a0008dbf88bc68341~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 5,
"department": {
"en_name": "Product RD and Infrastructure-Education-Open Language and KY-Client",
"id": "288980000064978549",
"name": "产品研发和工程架构部-教育-开言及青少年-客户端"
},
"department_name": "产品研发和工程架构部-教育-开言及青少年-客户端",
"digg_cnt": 26,
"email": "leishuai.ls@bytedance.com",
"employee_id": 1000007835,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Shuai Lei",
"entry_date": 1545609600,
"expert_category_ids": [],
"follow_count": 2,
"follower_count": 6,
"full_name": "雷帅",
"intro": "Less is more",
"is_follow": false,
"lark_id": "6638383381983789315",
"lark_open_id": "f4df9e78",
"leader": {
"email": "chenwei.spark@bytedance.com",
"employee_number": 7901308,
"en_name": "",
"id": 7901308,
"name": "陈伟",
"u_name": "陈伟 (chenwei.spark)"
},
"name": "雷帅",
"participate_time": 0,
"people_id": 3773562,
"question_cnt": 0,
"roleIds": [],
"score": 208,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "7b97928aace085fde5bacc73905c4f22"
}
],
"video_info": {
"collect_cnt": 361,
"comment_cnt": 0,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 5,
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1Lz1vBmTMpCApocxy8j9TpW_YGlt4oQnU/view?usp=sharing"
},
"duration": 2186,
"id_type": 24,
"item_id": "6844026125459390478",
"mtime": 1621760113,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-场景化自动化测试",
"url": "v02313a10000bqigvc7eqk8eup7c3g60",
"video_status": 1,
"view_cnt": 277
}
},
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 0,
"answer_digg_cnt": 0,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/3f04000d7d13dfcc9ddb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 3,
"department": {
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra",
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra"
},
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"digg_cnt": 2,
"email": "sunkun@bytedance.com",
"employee_id": 1000006878,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Kun Sun",
"entry_date": 1508716800,
"expert_category_ids": [],
"follow_count": 0,
"follower_count": 1,
"full_name": "孙坤",
"intro": "",
"is_follow": false,
"lark_id": "6479958980318724366",
"lark_open_id": "b34g4a31",
"leader": {
"email": "yuanhuihui@bytedance.com",
"employee_number": 9761123,
"en_name": "",
"id": 9761123,
"name": "袁辉辉",
"u_name": "袁辉辉 (yuanhuihui)"
},
"name": "孙坤",
"participate_time": 0,
"people_id": 5167160,
"question_cnt": 0,
"roleIds": [],
"score": 181,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "6e8fa5e4c5fbc61ad91b9cc59f51c1cc"
}
],
"video_info": {
"collect_cnt": 362,
"comment_cnt": 2,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 6,
"doc": {
"name": "edit?usp=sharing",
"url": "https://docs.google.com/presentation/d/1mfiTBf0njeSlrBWxd_kYncS4CHgfh6f_ihMWPy7NGj0/edit?usp=sharing"
},
"duration": 3977,
"id_type": 24,
"item_id": "6844026124440174606",
"mtime": 1621585471,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-Widget架构体系",
"url": "v02313a00000bpllf6ikr6g593makpr0",
"video_status": 1,
"view_cnt": 380
}
},
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 0,
"answer_digg_cnt": 0,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da5c000b07852577b06a~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 8,
"department": {
"en_name": "Product RD and Infrastructure-Client Infrastructure-Browser Kernel and Cross Platform-Lynx",
"id": "288980000065000863",
"name": "产品研发和工程架构部-Client Infrastructure-Browser Kernel and Cross Platform-Lynx"
},
"department_name": "产品研发和工程架构部-Client Infrastructure-Browser Kernel and Cross Platform-Lynx",
"digg_cnt": 3,
"email": "linyiyi@bytedance.com",
"employee_id": 1000008720,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Yiyi Lin",
"entry_date": 1560729600,
"expert_category_ids": [],
"follow_count": 0,
"follower_count": 1,
"full_name": "林一一",
"intro": "",
"is_follow": false,
"lark_id": "6703323720120795395",
"lark_open_id": "7a2e426d",
"leader": {
"email": "liushouqun@bytedance.com",
"employee_number": 3850189,
"en_name": "",
"id": 3850189,
"name": "刘守群",
"u_name": "刘守群 (liushouqun)"
},
"name": "林一一",
"participate_time": 0,
"people_id": 9232738,
"question_cnt": 0,
"roleIds": [],
"score": 128,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "fa4c5dabd1f892b7567313d1c578efe3"
}
],
"video_info": {
"collect_cnt": 366,
"comment_cnt": 5,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 6,
"doc": {
"name": "edit?usp=sharing",
"url": "https://docs.google.com/presentation/d/1Ckxx-PIUntqjlEz09ESdLfqATU4zH0EMtTOynDStGwk/edit?usp=sharing"
},
"duration": 3523,
"id_type": 24,
"item_id": "6844026123374821383",
"mtime": 1621760783,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-工程实战",
"url": "v02313dc0000bnu9mka7u0rau7jbb6j0",
"video_status": 1,
"view_cnt": 506
}
},
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 2,
"answer_digg_cnt": 7,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/98a40016945f75f4cd7e~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 24,
"department": {
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra",
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra"
},
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"digg_cnt": 154,
"email": "liufengkai@bytedance.com",
"employee_id": 1000007752,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Fengkai Liu",
"entry_date": 1531699200,
"expert_category_ids": [],
"follow_count": 4,
"follower_count": 19,
"full_name": "刘丰恺",
"intro": "摸了\n",
"is_follow": false,
"lark_id": "6578644913896816904",
"lark_open_id": "ecdgdbg9",
"leader": {
"email": "yuanhuihui@bytedance.com",
"employee_number": 9761123,
"en_name": "",
"id": 9761123,
"name": "袁辉辉",
"u_name": "袁辉辉 (yuanhuihui)"
},
"name": "刘丰恺",
"participate_time": 0,
"people_id": 3996153,
"question_cnt": 1,
"roleIds": [],
"score": 131,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "a44fc6c1db10806a79c08a458ca1acf6"
}
],
"video_info": {
"collect_cnt": 361,
"comment_cnt": 0,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 6,
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1EeM_NU2lN6YESeT1gFc8EGtd4awVYWyN/view?usp=sharing"
},
"duration": 3994,
"id_type": 24,
"item_id": "6844026126080147463",
"mtime": 1621585470,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-深耕 Compiler 体系结构",
"url": "v02313c60000br3na4mj5ugg78bjfng0",
"video_status": 1,
"view_cnt": 349
}
},
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 0,
"answer_digg_cnt": 0,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/2a9fcb33-2208-42f7-96b9-b532b585e8eg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 11,
"department": {
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra",
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra"
},
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"digg_cnt": 47,
"email": "wangying.666@bytedance.com",
"employee_id": 1000007759,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Ying Wang",
"entry_date": 1542758400,
"expert_category_ids": [],
"follow_count": 1,
"follower_count": 5,
"full_name": "王莹",
"intro": "",
"is_follow": false,
"lark_id": "6626140819768213773",
"lark_open_id": "aee6g776",
"leader": {
"email": "yuanhuihui@bytedance.com",
"employee_number": 9761123,
"en_name": "",
"id": 9761123,
"name": "袁辉辉",
"u_name": "袁辉辉 (yuanhuihui)"
},
"name": "王莹",
"participate_time": 0,
"people_id": 3110786,
"question_cnt": 0,
"roleIds": [],
"score": 156,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "a44fc6c1db10806adbe147a11135dba5"
}
],
"video_info": {
"collect_cnt": 364,
"comment_cnt": 0,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 5,
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1xSv2e-ZK7Yyex-kQQjVSgpQ4StjmWXft/view?usp=sharing"
},
"duration": 2357,
"id_type": 24,
"item_id": "6844026124943491086",
"mtime": 1621760301,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-性能优化最佳实践",
"url": "v02313910000bq7icm1pskdlvdut2pvg",
"video_status": 1,
"view_cnt": 296
}
},
{
"author": {
"answer_cnt": 3,
"answer_digg_cnt": 5,
"auth": 0,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 213,
"department": {
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community",
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区"
},
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"digg_cnt": 311,
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Conglin Wang",
"entry_date": 1543190400,
"expert_category_ids": [],
"follow_count": 3,
"follower_count": 76,
"full_name": "王丛林",
"intro": "一块儿橡皮玩一天～",
"is_follow": false,
"lark_id": "6628001948719120644",
"lark_open_id": "6cd9ee19",
"leader": {
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": "",
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)"
},
"name": "王丛林",
"participate_time": 0,
"people_id": 8506729,
"question_cnt": 5,
"roleIds": [],
"score": 1162,
"sequence_v2": {
"en_name": "Operations",
"id": 24,
"name": "运营"
},
"status": 1,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63"
},
"category": {
"Ctime": 1567509556,
"Mtime": 1606450002,
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"en_name": "Client",
"follow_count": 0,
"id": 3,
"is_follow": false,
"is_show": 1,
"item_count": 0,
"logo": "",
"name": "客户端",
"show_type": 3
},
"digg_infos": [],
"highlight": {},
"id_type": 24,
"is_collect": false,
"is_digg": false,
"item_set_info": {
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"content_mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"ctime": 1606051037,
"id": 19,
"id_type": 39,
"item_id": "6897936454698483725",
"item_list": [
{
"id_type": 24,
"item_id": "6844026122951196680"
},
{
"id_type": 24,
"item_id": "6844026125459390478"
},
{
"id_type": 24,
"item_id": "6844026124440174606"
},
{
"id_type": 24,
"item_id": "6844026123374821383"
},
{
"id_type": 24,
"item_id": "6844026126080147463"
},
{
"id_type": 24,
"item_id": "6844026124943491086"
},
{
"id_type": 24,
"item_id": "6844026123941068807"
}
],
"mtime": 1622714447,
"status": 0,
"tag": 1,
"title": "Flutter 专题课程"
},
"labels": [
{
"en_name": "Android",
"follow_count": 6774,
"icon": "",
"id": 3,
"is_follow": false,
"item_count": 1105,
"name": "Android"
},
{
"en_name": "Grand frontend",
"follow_count": 3,
"icon": "",
"id": 1713,
"is_follow": false,
"item_count": 10,
"name": "大前端"
},
{
"en_name": "Flutter special course",
"follow_count": 8,
"icon": "",
"id": 1724,
"is_follow": false,
"item_count": 7,
"name": "Flutter专题课程"
}
],
"owners": [
{
"answer_cnt": 0,
"answer_digg_cnt": 0,
"auth": 1,
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da730014af521a367fed~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"collect_cnt": 65,
"department": {
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra",
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra"
},
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"digg_cnt": 199,
"email": "yuanhuihui@bytedance.com",
"employee_id": 1000008607,
"employee_type_v2": {
"en_name": "Regular",
"id": 1,
"name": "正式"
},
"en_name": "Huihui Yuan",
"entry_date": 1557100800,
"expert_category_ids": [
3
],
"follow_count": 0,
"follower_count": 71,
"full_name": "袁辉辉",
"intro": "Gityuan",
"is_follow": false,
"lark_id": "6687750276985651469",
"lark_open_id": "c17e7gb9",
"leader": {
"email": "zhuyuanshuo@bytedance.com",
"employee_number": 7937698,
"en_name": "",
"id": 7937698,
"name": "朱元硕",
"u_name": "朱元硕 (zhuyuanshuo)"
},
"name": "袁辉辉",
"participate_time": 0,
"people_id": 9761123,
"question_cnt": 0,
"roleIds": [
1
],
"score": 358,
"sequence_v2": {
"en_name": "RD",
"id": 9,
"name": "技术"
},
"status": 1,
"xid": "7783babcb9a649cb74e823d99fa102b1"
}
],
"video_info": {
"collect_cnt": 362,
"comment_cnt": 1,
"content_mtime": 1574756006,
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"create_id": 1000004678,
"ctime": 1574756006,
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"digg_cnt": 6,
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1ZlzfTCl8f7oFCe3_aUqgzrmNSzIjmKbZ/view?usp=sharing"
},
"duration": 3104,
"id_type": 24,
"item_id": "6844026123941068807",
"mtime": 1621760696,
"original": 0,
"point_score": 0,
"set_id": "0",
"status": 0,
"tag": 100,
"title": "Flutter-性能工具实践及优化",
"url": "v023133b0000boarb4pum7lmsf1ida5g",
"video_status": 1,
"view_cnt": 313
}
}
],
"view_cnt": 3263,
"item_cnt": 7,
"is_collect": false,
"id_type": 39
},
{
"article_info": {
"title": "Flutter路由 - Navigator ",
"author_id": 1000008976,
"comment_count": 3,
"content": "\n## 前言\n\n这一次，我尝试以不贴一行源代码的方式向你介绍 Flutter 路由的实现原理，同时为了提高你阅读源码的积极性，除了原理介绍以外，又补充了两个新的模块：**从源码中学习到的编程技巧**，以及 **阅读源码之后对实际应用开发带来的帮助**。\n\n希望这样1+2的模式，可以诱导你以非常积极的心态，很轻松的学习到 Flutter 路由相关的知识。\n\n当然，不贴一行源代码，纯白话的讲解必然会隐藏很多细节知识，渴望知识的你一定不会满足的，所以我在原理介绍结束之后，又补充了一篇番外：贴了大段大段的纯源码解析的[《Flutter 路由源码解析》](https://bytekm.bytedance.net/kmf/articleDetail/2973)，知道大概原理的你再去读源码，一定会轻松很多吧，希望这样的模式可以有效的帮助到你！\n\n本文大纲：\n\n- Flutter 路由实现\n\t- Flutter 路由实现的底层依赖\n\t- Flutter 路由过程\n\t- *番外：[《Flutter 路由源码解析》](https://bytekm.bytedance.net/kmf/articleDetail/2973)*\n\n- Navigator 源码里非常值得学习的 Flutter 编程技巧\n\t- Flutter中的“命令式编程”：对象引用查找与远程局部更新\n\t- 元素自治\n\t- 私有类包装：隔离逻辑与Widget\n\n- 阅读 Navigator 源码之后对实际应用开发的帮助\n\t- 路由动态监听\n\t- 路由监听中，识别 弹窗 or Page \n\t- 动态添加 Widget\n\t- 易踩的坑：多Navigator嵌套情况下的错误路由查找\n\n\n## Flutter 路由实现\n\n### Flutter 路由实现的底层依赖\n如果你对 Flutter 的Widget Tree有些了解。应该知道 Flutter 中的根 Widget 是`RenderObjectToWidgetAdapter `,根 Widget 的 child 就是我们在`void runApp(Widget app)`中传入的自定义 Widget。\n\n从`runApp `开始，Flutter的列车便轰隆隆开动了。似乎一切都顺理成章，直到我们开始思考，执行`Navigator.push()`方法开启新的页面是如何实现的？\n\n再继续分析之前，我们不妨先自己想想：如果让你来设计，你会如何设计`Navigator`? 如果是我的话，我大概会这样设计, 然后把这个 `MyNavigator ` 放到 Widget 树的根部：\n\n```\n// 伪代码\nclass MyNavigator extends StatefulWidget{\n  ...\n  Map<String,Page> pageMap = ...;\n  String currentPage = \"one\";\n  \n  void setCurrentPage(String pageName){\n    setState(() {\n      currentPage = pageName;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return pageMap[currentPage];\n  }\n}\n```\n\n那Flutter是如何实现的呢？\n\n我们先看一个最普通的Flutter App 的 Widget 树结构：\n\n<p class=\"img-tip\" data-str=\"Widget Tree\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/e86284b0fd7449cd822508590c1f4faa~noop.png' height=537 width=327/></p>\n\n哈哈，这个图乍一眼看有点懵，陌生的 Widget 可能有点多，挨个简单解释一下：\n\n- RenderObjectToWidgetAdapter： Flutter 中的 root widget。\n\n- MyApp： 我们在`void runApp(Widget app)`中传入的自定义 Widget。\n\n- MaterialApp ： 就是那个Flutter 官方的 `MaterialApp `组件，通常我们会在自定义的根布局使用它，不用它的话很多官方Widget就没办法使用了。\n\n- Navigator: 实现路由跳转用的就是它，它也是一个Widget，已经早早的嵌入了 WidgetTree 中。它维护了一个`Route`集合，你调用push，pop方法时，`Navigator `都会以栈的方式对这个集合进行添加或删除，就是你所熟悉的界面栈。 （和我们所想的方案几乎一样是不是？）\n\n- Overlay: 顾名思义，一个可以实现一层层向上覆盖 Widget 的组件,它持有了一个集合`List<OverlayEntry>`，你可以获取这个 Widget 的引用来向集合中添加组件，使得新的组件覆盖在已有的组件上面。在`Navigator `体系中，你的`Route`对象，都将转化为`OverlayEntry `对象存入这个集合。\n\n- OverlayEntry: `OverlayEntry `在图中没有，因为它不是一个 Widget，而是一个纯纯的 Dart 类。`Overlay `维护的是一个纯 Dart 类集合，最后再根据这个 Dart 类集合去创建 Widget。为什么这样做呢？因为直接操作Widget并不是一件优雅安全的事情，这一点我们再下一节会将。\n\n- _Theatre: 这是一个私有类，并且只有Overlay使用了它。它的名字非常形象的表达了它的功能：剧院。你有很多组件以一层层覆盖的模式绘制在界面上，如果其中某一层的组件**以全屏不透明的模式**绘制在界面上，那它下层的组件就不需要再进行绘制了（下面的完全看不到了还绘制啥呀~）。` _Theatre`就在做这样的事，需要绘制的组件放置在“舞台之上”，其他不需要绘制的组件作为观众放置台下，仅 build 但不绘制。\n\n- Stack: 类似 Android 里的`FrameLayout `, 顺序绘制它的 child,第一个child被绘制在最底端，后面的依次在前一个child的上面。\n\n- _OverlayEntry: 上面我们有提到`OverlayEntry `，这个纯 Dart 类最终会以 `_OverlayEntry `的形式进入 Widget 树中。`Overlay `是以`_OverlayEntry `为最小 Widget 单位向`Stack `中添加 child 的。`_OverlayEntry `包裹了我们的自定义 Page。\n\n- MyPage：就是你自定义的页面。\n\n听起来`Overlay `和`Stack `功能完全一样？\n\n了解这个之前，你需要知道每个通过路由展示在界面的上的 Page 或 PopupWindow,都有两个状态值：\n\n- opaque：是否是全屏不透明的，当一个组件`opaque=true`时，那么可以认为它之下的组件都不需要再绘制了。一般情况下，一个 Page 的`opaque=true`， 不是全屏的 PopupWindow `opaque=false`。\n- maintainState：一个已经不可见(被上面的盖住完全看不到啦~)的组件，是否还需要保存状态。当`maintainState=true`时，会让这个组件继续活着，但不会再进行绘制操作了。如果`maintainState=false`，则不会继续维持这个 Widget 的生存状态了。\n\n画个图来解释下，线框代表屏幕，长条代表一个个层叠绘制在屏幕上的组件。蓝色代表需要被绘制，黄色代表需要维持它活着但不需要绘制，灰色代表可以被抛弃的。\n\n<p class=\"img-tip\" data-str=\"opaque&maintainState\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/4ff4825cf1a246e688abca87cd7f7a27~noop.png' height=534 width=579/></p>\n\n\n好了，知道这两个知识点以后，我们继续讲`Overlay `和`Stack `。\n\nOverlay 的能力趋向于是一种逻辑管理，它维护了所有准备要绘制到界面上的组件。并倒序（后加入的组件绘制到最上方）遍历这些组件，最开始每个组件都有成为“演员的机会”，直到某个组件的`opaque ` 的值为 true , 后面的组件便只有做 “观众” 的机会了，对于剩下的组件，判断他们的`maintainState ` 值，为 true 的才有机会做观众，为false的没有入场机会了，他们这一阶段的生命周期将结束。之后将分类完成的“演员”和“观众”交给 _Theatre。\n\n`_Theatre`维护了两个属性：`onstage`和`offstage`，`onstage`里又持有了一个`Stack `，将所有的“演员”加入`Stack `中，依次覆盖绘制。`offstage`维护了所有的“观众”，只`build`他们，但不绘制。\n\n`Overlay ` 管理`OverlayEntry ` 的逻辑类似下面这张图：\n\n<p class=\"img-tip\" data-str=\"Overlay\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/99c37e518b0548f89e78f18643fa71d5~noop.png' height=511 width=928/></p>\n\n\n可能你会比较好奇`_Theatre`中 `offstage` 是如何做到不绘制的。\n\n你应该知道 Element 树的是通过其内部的`mout`方法将自己挂载到父 Element 上的。`_Theatre`的 `mout`方法不太一样， `onstage`走正常的挂载流程，加入到`Element` 树中； `offstage`集合中的 Widget 仅创建了对应的 `Element`，并没有挂载到 `Element` 树中。没有进入到`Element`中，也就不会进入到 `RenderObject`树中，也就不走到绘制流程了。\n\n这样你应该能理解`Overlay `其实是`Stack `的扩展。`Overlay `预先进行过滤，从而避免了无用的绘制。\n\n\n### Flutter 路由过程\n\n经过上面讲的 Widget 树结构以及`Overlay `的能力和原理，你大概能猜到`Navigator `就是在`Overlay `的基础上扩展实现的。那具体是怎样一个过程呢？\n\n你已经知道`Navigator `维护了一个 `Route` 集合（就是一个很普通的 List）。你调用`push `方法向集合中增加一个 `Route`时， 也同时会创建出两个对应的`OverlayEntry `, 一个是遮罩（对原理解释并不是很重要，后面我们会忽略它，你只要知道就好了），一个代表 Page 本身。\n\n我们看下当路由中只有一个 Page 时的示意图：\n\n<p class=\"img-tip\" data-str=\"one page\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/0a163feee1b5480d868eb0251fdfe419~noop.png' height=408 width=1140/></p>\n\n`Navigator ` 持有一个 `Route` 集合，里面只有一个 Page。同样的，`Navigator `内部的`Overlay `也持有一个`OverlayEntry `集合，并且有与 Page 对应的`OverlayEntry `。需要提醒的是，`Route`与`OverlayEntry `并不是一一对应的，而是1:2，上面我们讲了还有一个遮罩，只是这里为了图示简单，省略了它。\n\n因为只有一个 Page 需要展示，所以它在`_Theatre`的`onstage`的`Stack`里，最终将被绘制。此时`offstage `为空。\n\n我们再看下当路由中又被 push 进一个 Page时的情况：\n\n<p class=\"img-tip\" data-str=\"two page\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/4aa20d97e85a424d8fa5233a3e327c3d~noop.png' height=419 width=1140/></p>\n\n\n因为通常 Page 的 `opaque=true, maintainState=true`,所以 Page2 进入 `onstage`， Page1 不在需要被绘制，但需要保持状态，进入了`offstage `。\n\n当我们再次向路由中 push 一个 Page：\n\n<p class=\"img-tip\" data-str=\"three page\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/5c394b2f5e8c489ba8334287dd0dc82c~noop.png' height=450 width=1140/></p>\n\n\n我们已经看了3个 Page 的情况，再看一个 popupWindow（dialog） 的情况，因为通常 popupWindow（dialog） 的 `opaque=false`,我们再向路由中 push 一个 dialog:\n\n<p class=\"img-tip\" data-str=\"push dialog\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/28c6ddd4edda4ca2a7fbc5e156c55110~noop.png' height=511 width=1140/></p>\n\n\n因为 dialog 并不是全屏不透明的，它下面还是要展示Page的一部分，所以它要和 Page 一起绘制在屏幕上，只不过 dialog 在最上层。\n\npop 的过程就是 push的反向，把4张图倒着看一遍就ok啦。\n\n这里只讲了最简单的 push ，`Navigator `还提供了丰富的push和pop方法，但最终只是最基础的push或pop的扩展。\n\n比如`pushNamed`,其实就是通过字符串匹配创建出对应的`Route`，然后调用`push`方法；`pushReplacement`其实就是push的同时`pop`出旧的`Route`,以你的聪明才智，一定很轻易就能猜到实现逻辑的，这里我就不多介绍啦。\n\n\n### *番外：《Flutter 路由源码解析》*\n\n求知欲如此之强的你，一定渴望更多的细节。如果你还精力旺盛，就继续跟我去看看源码吧~\n\n[番外：《Flutter 路由源码解析》](https://bytekm.bytedance.net/kmf/articleDetail/2973)\n\n不阅读源码不影响接下来的阅读哦~，但如果读过之后，下面的内容会更香！\n\n## Navigator 源码里非常值得学习的Flutter 编程技巧\n\nNavigator 体系的源码，阅读理解起来，不是特别难，但也有一定的复杂性。所以其中包含了一些非常值得学习的 Flutter风格编程技巧。\n\n\n### Flutter中的“命令式编程”：对象引用查找与远程局部更新\n\n区别于Androdi&iOS的命令式编程范式，Flutter 声明式的编程范式早期会给开发者带来极大的不适。最大的改变在于UI的更新是通过 rebuild 来实现的，以及对象引用的概念被弱化了（如果每一次都是重新创建，那持有一个 Widget 的引用也就不是很重要了）。\n\n这样的改变较为容易引起你不适的点在于：\n\n- 1.在 Widget 树中，对某个 Widget 的引用获取。\n\n\t偶尔依然会有获取某个Widget引用的需求；\n\t\n- 2.参数层层传递问题。\n\n\t如果顶层持有的某个参数需要被传递到底层，层层传递是一件非常痛苦的事。如果能直接拿到上层 Widget 的引用，获取该 Widget 持有的参数的话就很方便了。\n\t\n- 3.当触发更新的点和要被更新的点在代码上距离较远时。\n\n\t若没有借助 Redux 等框架, 通常我们会将【触发更新的点】和【被更新的点】封装在尽可能小的范围里（封装在一个范围最小的StatefulWidget中）。但总有十万八千里的两个有缘人，这个时候触发大范围，甚至整颗Widget树的rebuild的话就不是很优雅了。\n\t\n那这三个点如何解决呢？\n\n在 Navigator 的源码体系里，有两个关键对象对外提供了全局引用的能力，分别是：`Navigator ` 和 `Overlay `，借助的均是 `BuildContext`的 `ancestor*`方法向上查找。\n\n`BuildContext` 是 `Element` 的抽象类，所以`BuildContext`的查找也就是在 Element 树中遍历查找需要的元素。\n\n我们看看`BuildContext`都提供了哪些方法：\n\n```\nancestorInheritedElementForWidgetOfExactType --- 向上查找最近的InheritedWidget的 InheritedElement\ninheritFromWidgetOfExactType --- 向上查找最近的InheritedWidget\nancestorRenderObjectOfType   --- 向上查找最近的给定类型的RenderObject\nancestorStateOfType --- 向上查找最近的给定类型的StatefulWidget的State对象\nancestorWidgetOfExactType   --- 向上查找最近的给定类型的Widget\nfindRenderObject  --- 向下查找当前的RenderObject\nrootAncestorStateOfType  --- 向上查找最顶层的给定类型的 State\n\nvisitAncestorElements（bool visitor（Element element）） --- 向上遍历 Ancestor\n```\n\n向上查找较为简单，传入对应类型即可，向下`BuildContext`也提供了遍历 child的方法：\n```\nvisitChildElements（ElementVisitor visitor）  --- 向下遍历 child\n```\n\n以`Overlay `的静态方法`of`方法为例(`Navigator`也有类似的`of`方法),传入需要查找的类型对象`TypeMatcher `,向上查找到最近的`OverlayState `,使得`Overlay `无需层层向下传递自己的引用，底层 Widget 遍可以在任何地方拿到`Overlay `引用，并调用它的方法或属性，这解决`1``2`的问题：\n\n```\nclass Overlay {\n...\nstatic OverlayState of(BuildContext context, { Widget debugRequiredFor }) {\n    final OverlayState result = context.ancestorStateOfType(const TypeMatcher<OverlayState>());\n    ...\n    return result;\n}\n...\n```\n\n那么对于相聚千里之外的有缘人，如何通知对方 rebuild 呢？ `Overlay `也给了我们很好的示例，以 `OverlayState`的`insert `方法为例：\n\n通过`Overlay `的静态方法`of`获取到`OverlayState`引用之后，调用`insert `,其内部直接调用了`setState(() {}` 方法修改了自己的数据内容，并触发了自己范围内的 rebuild 。 \n\n```\nvoid insert(OverlayEntry entry, { OverlayEntry above }) {\n    entry._overlay = this;\n    setState(() {\n      final int index = above == null ? _entries.length : _entries.indexOf(above) + 1;\n      _entries.insert(index, entry);\n    });\n  }\n```\n\n这样，`1``2``3`点便有了相应的解决方案，开发过程中不妨考虑用这样的方式优化你的代码。\n\n但在Element树中遍历查找引用以及操作，毕竟不是一件高效和安全的事情，所以在某些场景下，可以考虑下面的一个技巧：“元素自治”。\n\n### 元素自治\n\n最佳示例依然来自于`Overlay `。 \n\n传统编程思维方式中，集合负责存储元素，元素持有数据，某个 Manager 负责操作集合与集合里的元素。\n\n`OverlayState `提供了三个操作集合的方法：\n\n```\n  void insert(OverlayEntry entry, { OverlayEntry above }) \n  void insertAll(Iterable<OverlayEntry> entries, { OverlayEntry above }) \n  void _remove(OverlayEntry entry) \n```\n\n受限于 Flutter 声明式的编程方式，对象引用的查找成本较高，Manager 的实现在这个场景里也不够优雅。所以虽然`insert`方法依然需要通过`Overlay `的静态方法`of`查找`OverlayState `引用来调用。 但`_remove`却是一个私有方法，不允许你直接通过`OverlayState `来调用。\n\n`OverlayEntry`的删除只能由`OverlayEntry`自己来执行：\n\n```\nclass OverlayEntry {\n  ...\n  void remove() {\n    final OverlayState overlay = _overlay;\n    _overlay = null;\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n        overlay._remove(this);\n      });\n    } else {\n      overlay._remove(this);\n    }\n  }\n  ...\n```\n\n这样的编程方式，既保证了元素“安全”，又避免了在树中的查找的损耗。\n\n安全的理由是：元素的删除不仅是从集合中删除就结束了，还有一系列“卸载”和回调的需要被执行，元素自治屏蔽了外部直接操作集合删除元素的可能。\n\n\n### 私有类包装：隔离逻辑与Widget\n\n如果需要你来自定义一个Widget，这个Widget内部持有了多个children，这些children都是在不断变化的。你会怎么维护这个children列表呢？\n\n直接创建一个 `List<Widget>` 集合吗？不，这并不优雅也不安全！\n\n我们知道 Widget 是 Flutter 里的基础基石，每一个Widget在run起来之后都有无限的延伸，可能是短命不可复用的可能又是长期存在的，它们不但可以产出Element和RenderObject，还包括了完整的生命周和体系内的各种回调。\n\n你可以保证能照顾好他们吗？\n\nFlutter 世界里的一个潜规则是：Wideget的创建，尽可能只在build方法中进行！将Wideget的创建和销毁交给Flutter 系统来维护！\n\n那么该如何做呢？\n\n第三个示例还是来自于`Overlay `， `Overlay `的设计真的不错！\n\n`Overlay ` 内部也持有了多个children：`List<OverlayEntry>` ，但`OverlayEntry`并不是一个Widget，它只是一个普通的 Dart 类。它持有了创建Widget必要的属性以及一些逻辑。\n\n而`Overlay `在build时真正创建的 Widget 是`_OverlayEntry `：\n\n\n```\nclass _OverlayEntry extends StatefulWidget {\n  _OverlayEntry(this.entry)\n    : assert(entry != null),\n      super(key: entry._key);\n\n  final OverlayEntry entry;\n\n  @override\n  _OverlayEntryState createState() => _OverlayEntryState();\n}\n\nclass _OverlayEntryState extends State<_OverlayEntry> {\n  @override\n  Widget build(BuildContext context) {\n    return widget.entry.builder(context);\n  }\n\n  void _markNeedsBuild() {\n    setState(() { /* the state that changed is in the builder */ });\n  }\n}\n```\n\n可以看到`_OverlayEntry `是一个私有类，它的代码非常简单，构造方法里传入一个`OverlayEntry `,build 时执行的是`entry.builder(context)`方法。\n\n所以：如果你需要对一个Widget或Widget集合做频繁的操作，建议的做法是将逻辑和属性抽离出来，维护一个不变的逻辑对象，让Widget根据逻辑对象进行build或rebuild。 尽量避免直接操作一个Widget以及改变它内部的属性。\n\n\n## 阅读 Navigator 源码之后对实际应用开发的帮助\n\n源代码的阅读往往可以加深对系统执行过程的理解，在将来的某一天可能会起到至关重要的作用，却也可能永远用不到。这种收益的不确定性和源码阅读的枯燥性，往往会让大部分人望而却步。\n\n所以在文章的最后，我简单的列出一些在源码阅读之后，对实际应用开发的帮助。由此，来增加你对源码学习的积极性。\n\n### 路由动态监听\n\n随着开发复杂度的上升，你一定会有监听路由变化的需求。如果你对`MaterialApp`有些许研究，会知道在构建`MaterialApp`时可以传入一个`navigatorObservers`的参数，大概像这样：\n\n```\n  Widget build(BuildContext context) {\n    return new MaterialApp(\n      navigatorObservers: [new MyNavigatorObserver()],\n      home: new Scaffold(\n        body: new MyPage(),\n      ),\n    );\n  }\n```\n\n`navigatorObservers`是一个`List<NavigatorObserver>`集合，每当navigator发生变动时，都会遍历这个集合回调对应的方法。\n\n即使你不知道`MaterialApp`有这样一个属性，在阅读`NavigatorState`源码时，`pop`,`push`等方法内部都有下面这样的代码, 了解到路由的变化是提供了`observer `的：\n\n```\n  @optionalTypeArgs\n  Future<T> push<T extends Object>(Route<T> route) {\n  \t...\n    for (NavigatorObserver observer in widget.observers)\n      observer.didPush(route, oldRoute);\n\t...\n  }\n```\n\n另一个问题来了！\n\n一个标准的工程，往往会将`MaterialApp`申明在最顶层，而大部分需要监听路由变动的场景，都在下层的业务代码里。笨办法是将监听函数层层传递，但这绝对是一个极其痛苦的过程。\n\n一个相对优雅的解决方案是：动态添加路由监听。那如何实现呢？\n\n`Navigator`和`NavigatorState`并没有直接暴露添加监听的接口（是官方并不建议吗？），但看过源码的你会知道，最终回调的`observers`是由`Navigator`持有的`observers`对象，幸好它是一个public属性。\n\n所以，动态添加路由监听的方法可以这样实现：\n\n```\n  MyNavigatorObserver myObserver = MyNavigatorObserver();\n\n  @override\n  void initState() {\n    super.initState();\n    //建议在initState时动态添加Observer，而不是build时，避免重复添加\n    Navigator.of(context).widget.observers.add(myObserver);\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    //dispose时记得移除监听\n    Navigator.of(context).widget.observers.remove(myObserver);\n  }\n  \n```\n\n### 路由监听中，识别 弹窗 or Page \n\n一个较为困扰的事情是，在 Flutter 的世界中，无论是页面还是弹窗，都是以路由的方式来实现的，所以在路由监听的回调中，弹窗的展示和消失也会触发回调。\n\n如果你想识别回调中的路由是弹窗还是Page该怎么办？ 有没有什么较为优雅的方式？\n\n读过源码的你一定记得，在`OverlayState`的 build 方法中，通过`OverlayEntry`的`opaque`属性，将所有将要进入`_Theatre`组件中的`entry`区分为了`onstageChildren`和`offstageChildren`。\n\n`opaque`意义在哪呢？它决定了当前的Widget是否是一个“全屏不透明”的Widget，Page一般情况下占用全部屏幕，所以他是“全屏不透明的”，弹窗一般情况下只占用全部屏幕的一部分，所以它的“全屏透明的”。\n\n读过源码的你会知道，`Route`的子类`TransitionRoute`持有了`opaque`属性，并且所有的\"PageRoute\"`opaque=true`,\"PopupRoute\"`opaque=false`。\n\n那么事情就很简单了：\n\n```\nclass MyNavigatorObserver extends NavigatorObserver {\n  @override\n  void didPush(Route<dynamic> route, Route<dynamic> previousRoute) {\n    if ((previousRoute is TransitionRoute) && previousRoute.opaque) {\n      //全屏不透明，通常是一个page\n    } else {\n      //全屏透明，通常是一个弹窗\n    }\n  }\n}\n```\n\n值得注意的是，`opaque`值并不能完全代表它是一个Page或弹窗，总是会有特殊情况的。所以对这一点的理解，更准确的说法是：识别`previousRoute `是否会占据全部屏幕，导致原本的`route`不可见。\n\n### 动态添加 Widget\n\n受限于Flutter 独特的编程方式，想要在代码中随时插入一个 Widget 还是比较困难的。\n\n但读过源码的你已经知道了，在`MaterialApp`中已经预先内置了一个`Overlay `,虽然它是给 `Navigator`服务的，但你也完全可以拿来用：\n\n```\n//获取最近的一个Overlay进行操作，如果你没有添加自定义的，通常是`Navigator`的那个\nOverlay.of(context).insert(entry);\n\n//获取最靠近根部的Overlay进行操作，通常是`Navigator`的那个\n(context.rootAncestorStateOfType(const TypeMatcher<OverlayState>()) as OverlayState).insert(entry);\n\n```\n\n### 易踩的坑：多Navigator嵌套情况下的错误路由查找\n\n成也 Widget，败也 Widget。万物皆 Widget 可以有无限的组合，但也可能导致 Widget 的滥用。\n\n`MaterialApp ` 在 Flutter 世界中的地位类似于 Android 中的 `Application` + `BaseActivity`。 理论上一个项目中只应该在顶层有唯一的一个`MaterialApp ` ，但 Flutter 却也不限制你在 Widget 树中任意地方使用多个`MaterialApp `。\n\n另外`Navigator`也是一个 Widget，你也可以在树中的任意地方插入任意多个`Navigator`。\n\n这会造成什么问题呢？假设我们有这样一个 Widget 树：\n\n```\n- MaterialApp\n\t- ...\n\t\t-  Navigator\n\t\t\t- ...\n\t\t\t\t-  MaterialApp\n\t\t\t\t-  Navigator\n\t\t\t\t\t- ...\n\t\t\t\t\t- MaterialApp\n```\n\n你猜这个 Widget 树里有多少个 `Navigator `? 看过源码你知道每个`MaterialApp `内部都包含一个`Navigator `,所以这棵树里有5个`Navigator `。 这么多`Navigator `的问题在哪呢？\n\n看下`Navigator `的`push`方法：\n\n```\nstatic Future<T> push<T extends Object>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n  }\n```\n\n默认调用的是单个参数的`Navigator.of(context)`,在看下`of`内部：\n\n```\nstatic NavigatorState of(\n    BuildContext context, {\n      bool rootNavigator = false,\n      bool nullOk = false,\n    }) {\n    final NavigatorState navigator = rootNavigator\n        ? context.rootAncestorStateOfType(const TypeMatcher<NavigatorState>())\n        : context.ancestorStateOfType(const TypeMatcher<NavigatorState>());\n    return navigator;\n}\n```\n\n默认情况下，向上查找的不是根节点的`NavigatorState `,而是最近的一个。这将导致你在树中任意位置`push`或`pop`操作的可能不是同一个`NavigatorState `对象，他们维护的也不是同一个 `route`栈，这将导致很多问题。\n\n所以合适的做法是：\n\n- 1.尽可能保证你的代码中，`MaterialApp `在项目中有且只有一个，且在Widget 树的顶层。\n\n- 2.你不能保证代码中只有一个`Navigator`, 所以对于全局的Page管理，建议将`push`或`pop`封装，使用`Navigator.of(context, rootNavigator:true)`代码去保证你拿的是根部的`Navigator`。\n\n\n而对于真的有需要去获取树中的某个`Navigator`而不是根`Navigator`，你要严格 check `Navigator.of(context)` 中你所使用的 `BuildContext`，要保证它是在你要获取的 `Navigator` 之下的。\n\n一个 badcase:\n\n```\nclass MyWidget extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Stack(\n      children: <Widget>[\n        MyNavigator(), \n        GestureDetector(\n          onTap: (){\n            Navigator.of(context);\n          },\n          child: Text(\"ClickMe\"),\n        )\n      ],\n    );\n  }\n}\n```\n\n`MyNavigator `是我们自定义的`Navigator `,我们需要点击“ClickMe”来在树中查找到`MyNavigator `的引用，那么，你觉得能查的到吗？\n\n答案是不能！因为我们是基于`MyWidget `的`BuildContext `（`BuildContext `就是`Element`的抽象）去在Element树中向上查找的，但很明显`MyWidget `在 `MyNavigator `上层，当然不会得到你想要的结果啦~\n\n\t\n\n\t\n\n\n\n\n\n\n",
"ctime": 1552290718,
"mtime": 1622701931,
"commentable": 0,
"status": 0,
"dig_cnt": 13,
"collect_cnt": 7,
"cover_url": "",
"brief": "",
"article_id": "2974",
"draft_id": "6920191433085288461",
"view_cnt": 2099,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "Flutter Routing-Navigator\n",
"en_content": "## Preface\n\nThis time, I tried to introduce you to the implementation principle of Flutter routing without pasting a line of source code. At the same time, in order to improve your enthusiasm for reading the source code, in addition to the introduction of the principle, I added two new modules:**Programming skills learned from source code**, and**After reading the source code for practical application development help**。\n\nHopefully, this 1 + 2 mode can induce you to learn Flutter routing related knowledge with a very positive attitude.\n\nOf course, if you don't paste a line of source code, the explanation in plain English will inevitably hide a lot of detailed knowledge, and you will not be satisfied if you are eager for knowledge. Therefore, after the introduction of the principles, I added another article: I posted a large section of pure source code analysis[Flutter routing source code analysis](https://bytekm.bytedance.net/kmf/articleDetail/2973)If you read the source code again if you know the general principle, it will be much easier. I hope this mode can effectively help you!\n\nOutline of this article:\n\n*   Flutter routing implementation\n    *   The underlying dependencies of Flutter routing implementation\n    *   Flutter routing process\n    *   *Fanwai:[Flutter routing source code analysis](https://bytekm.bytedance.net/kmf/articleDetail/2973)*\n\n*   Flutter programming skills in Navigator source code are worth learning\n    *   \"Imperative Programming\" in Flutter: Object Reference Lookup and Remote Local Updates\n    *   Element autonomy\n    *   Private class wrapping: isolating logic from widgets\n\n*   Help for practical application development after reading Navigator source code\n    *   Route dynamic monitoring\n    *   Route Monitoring, Identification, Popup or Page\n    *   Add Widget dynamically\n    *   Easy-to-Tread Pit: Error Route Finding in Multi-Navigator Nested Cases\n\n## Flutter routing implementation\n\n### The underlying dependencies of Flutter routing implementation\n\nIf you know something about Flutter's Widget Tree. You should know that the root Widget in Flutter is` RenderObjectToWidgetAdapter  `Widget,, the child we found`void runApp(Widget app)`The custom widget passed in.\n\nFrom` runApp  `At first, the Flutter train started to rumble. Everything seemed to be logical until we began to think and execute`Navigator.push()`How does the method open a new page?\n\nBefore continuing the analysis, we might as well think for ourselves: if you were to design, how would you design`Navigator`? If it were me, I would probably design it like this and put this` MyNavigator  `Put it at the root of the widget tree:\n\n    // pseudo code\n    class MyNavigator extends StatefulWidget{\n    ...\n    Map < String, Page > pageMap =...;\n    String currentPage = \" one \";\n\n    void setCurrentPage (String pageName) {\n    setState (() {\n    currentPage = pageName;\n    });\n    }\n\n    @Override\n    Widget build (BuildContext context) {\n    Return pageMap [currentPage];\n    }\n    }\n\nSo how does Flutter work?\n\nLet's take a look at the widget tree structure of the most common Flutter App:\n\n<p class=\"img-tip\" data-str=\"Widget Tree\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/e86284b0fd7449cd822508590c1f4faa~noop.png' height=537 width=327/></p>\n\nHaha, this picture is a bit confused at first sight, and there may be a lot of strange widgets.\n\n*   RenderObjectToWidgetAdapter: The root widget in Flutter.\n\n*   MyApp: We are`void runApp(Widget app)`The custom widget passed in.\n\n*   MaterialApp: It's the official Flutter` MaterialApp  `Component, usually we will use it in the custom root layout, without which many official widgets cannot be used.\n\n*   Navigator: It is used to realize route jump. It is also a widget, which has been embedded in the widget tree early. It maintains a`Route`Collection, when you call push, pop methods,` Navigator  `Will add or remove this collection in the form of a stack, which is the interface stack you are familiar with. (Is it almost the same as what we thought?)\n\n*   Overlay: As the name implies, a component that can cover the widget layer by layer, which holds a collection`List<OverlayEntry>`, you can get a reference to this widget to add a component to the collection so that the new component overrides the existing component. In` Navigator  `In the system, your`Route`Objects will be transformed into` OverlayEntry  `Objects are stored in this collection.\n\n*   OverlayEntry: ` OverlayEntry  `Not in the diagram, because it is not a widget, but a pure Dart class.` Overlay  `Maintain a collection of pure Dart classes, and finally create widgets based on this collection of Dart classes. Why do you do this? Because directly operating widgets is not an elegant and safe thing, which we will see in the next section.\n\n*   \\_Theatre: This is a private class, and only Overlay uses it. Its name vividly expresses its function: theater. You have many components drawn on the interface in a layer-by-layer pattern, if one of the components of one layer**In full screen opaque mode**If it is drawn on the interface, the components at its lower level do not need to be drawn any more (what else can be drawn if you can't see it at all below ~).`  _Theatre `In doing such a thing, the components that need to be drawn are placed \"on the stage,\" while other components that do not need to be drawn are placed under the stage as spectators, only build but not draw.\n\n*   Stack: Similar to Android` FrameLayout  `, Draw its child in sequence, the first child is drawn at the bottom, and the last one is drawn on top of the previous child.\n\n*   \\_OverlayEntry: We mentioned above` OverlayEntry  `, this pure Dart class will eventually` _OverlayEntry  `Into the Widget tree.` Overlay  `Is based on` _OverlayEntry  `Minimum Widget Unit` Stack  `Add child.` _OverlayEntry  `Wrapped our Custom Page.\n\n*   MyPage: It is the page you customize.\n\nSounds` Overlay  `And` Stack  `The function is exactly the same?\n\nBefore you know this, you need to know that each page or PopupWindow displayed on the interface through routing has two status values:\n\n*   Opaque: Whether it is full screen opaque when a component`opaque=true`When, then it can be considered that the components under it do not need to be drawn any more. In general, a Page`opaque=true`, Not a full-screen PopupWindow`opaque=false`。\n*   MaintainState: Do you still need to save the state of a component that is no longer visible (it is completely invisible when covered by the above ~). When`maintainState=true`Will keep this component alive, but will no longer draw. If`maintainState=false`, it will not continue to maintain the survival state of this widget.\n\nDraw a picture to explain that the wireframe represents the screen, and the strip represents the components drawn on the screen one by one. Blue represents the need to be drawn, yellow represents the need to keep it alive but does not need to be drawn, and gray represents the need to be discarded.\n\n<p class=\"img-tip\" data-str=\"opaque&maintainState\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/4ff4825cf1a246e688abca87cd7f7a27~noop.png' height=534 width=579/></p>\n\nWell, after knowing these two knowledge points, let's continue` Overlay  `And` Stack  `。\n\nOverlay's ability tends to be a kind of logical management, which maintains all components that are ready to be drawn on the interface. And traverse these components in reverse order (the components added later are drawn to the top). At the beginning, each component has the opportunity to become an \"actor\" until a component's` opaque  `If the value of is true, the following components will only have the chance to be \"viewers.\" For the remaining components, judge their` maintainState  `Value, only those who are true have the opportunity to be spectators, and those who are false have no chance to enter, and their life cycle at this stage will end. After that, the \"actors\" and \"spectators\" who have completed the classification will be handed over to the \\_Theatre.\n\n`_Theatre`Two properties are maintained:`onstage`And`offstage`，`onstage`Another one` Stack  `, adding all the \"actors.\"` Stack  `In, overwrite the drawing in turn.`offstage`Maintained all the \"audience,\" only`build`They are, but not drawn.\n\n` Overlay  `Management` OverlayEntry  `The logic is similar to the following picture:\n\n<p class=\"img-tip\" data-str=\"Overlay\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/99c37e518b0548f89e78f18643fa71d5~noop.png' height=511 width=928/></p>\n\nMaybe you will be more curious`_Theatre`In`offstage`How to do it without drawing.\n\nYou should know that the Element tree is through its internal`mout`Method to mount itself on the parent Element.`_Theatre`Of`mout`The method is different,`onstage`Follow the normal mount process and join`Element`In the tree;`offstage`Widgets in the collection only create the corresponding`Element`, did not mount to`Element`In the tree. Did not enter`Element`In, it will not enter`RenderObject`In the tree, the drawing process will not be reached.\n\nSo you can understand` Overlay  `Actually` Stack  `Extension.` Overlay  `Filtered in advance, thus avoiding useless drawing.\n\n### Flutter routing process\n\nAfter the widget tree structure mentioned above and` Overlay  `Ability and principle, you can probably guess` Navigator  `Is in` Overlay  `Based on the expansion of the implementation. What is the specific process?\n\nYou already know` Navigator  `Maintained one`Route`Collection (just a very common List). You call` push  `Method adds one to the collection`Route`At the same time, two corresponding` OverlayEntry  `, One is the mask (it is not very important to explain the principle, we will ignore it later, you just need to know), and the other represents the Page itself.\n\nLet's take a look at the schematic diagram when there is only one page in the route:\n\n<p class=\"img-tip\" data-str=\"one page\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/0a163feee1b5480d868eb0251fdfe419~noop.png' height=408 width=1140/></p>\n\n` Navigator  `Hold one`Route`Collection, there is only one Page in it. Similarly,` Navigator  `Internal` Overlay  `Also hold one` OverlayEntry  `Collection, and there is a page corresponding to` OverlayEntry  `. Need to remind,`Route`With` OverlayEntry  `It is not one-to-one correspondence, but 1:2. We mentioned above that there is also a mask, but it is omitted here for the sake of simplicity.\n\nBecause there is only one page to display, it is in`_Theatre`Of`onstage`Of`Stack`Will eventually be drawn. At this time` offstage  `Is empty.\n\nLet's look at the situation when another page is pushed into the route:\n\n<p class=\"img-tip\" data-str=\"two page\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/4aa20d97e85a424d8fa5233a3e327c3d~noop.png' height=419 width=1140/></p>\n\nBecause usually Page`opaque=true, maintainState=true`So, Page2 enters`onstage`, Page1 does not need to be drawn, but needs to remain in state, entered` offstage  `。\n\nWhen we push a Page into the route again:\n\n<p class=\"img-tip\" data-str=\"three page\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/5c394b2f5e8c489ba8334287dd0dc82c~noop.png' height=450 width=1140/></p>\n\nWe have already looked at the situation of 3 pages, and then look at the situation of a popup Window (dialog), because usually the popup Window (dialog)`opaque=false`, Let's push another dialog to the route:\n\n<p class=\"img-tip\" data-str=\"push dialog\"><img src='https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/28c6ddd4edda4ca2a7fbc5e156c55110~noop.png' height=511 width=1140/></p>\n\nBecause the dialog is not full-screen opaque, it still shows a part of the Page below, so it should be drawn on the screen with the Page, but the dialog is at the top.\n\nThe process of pop is the reverse of push, just look at the 4 pictures backwards.\n\nHere is only the simplest push,` Navigator  `It also provides rich push and pop methods, but in the end it is only the most basic push or pop extension.\n\nLike`pushNamed`, In fact, it is through character string matching to create the corresponding`Route`, and then call`push`Methodology;`pushReplacement`Actually push at the same time`pop`Old`Route`With your intelligence, you can easily guess the logic of implementation. I won't introduce it here.\n\n### *Flutter routing source code analysis*\n\nWith such a strong thirst for knowledge, you must be eager for more details. If you are still energetic, continue to follow me to see the source code ~\n\n[Flutter routing source code analysis](https://bytekm.bytedance.net/kmf/articleDetail/2973)\n\nNot reading the source code will not affect the following reading, but if you read it, the following content will be more fragrant!\n\n## Flutter programming skills in Navigator source code are worth learning\n\nThe Navigator source code is not particularly difficult to read and understand, but it also has a certain degree of complexity. Therefore, it contains some Flutter-style programming skills that are worth learning.\n\n### \"Imperative Programming\" in Flutter: Object Reference Lookup and Remote Local Updates\n\nUnlike Androdi & iOS's imperative programming paradigm, Flutter's declarative programming paradigm was very uncomfortable for developers in the early days. The biggest changes are that UI updates are implemented through rebuild, and the concept of object references has been weakened (if every time it is recreated, it is not very important to hold a Widget reference).\n\nThe point that such changes are more likely to cause you discomfort is:\n\n*   1\\. In the Widget tree, get a reference to a Widget.\n\n    Occasionally, there is still a need to get a Widget reference;\n\n*   2\\. The problem of parameter transfer layer by layer.\n\n    If a parameter held by the top layer needs to be passed to the bottom layer, passing it layer by layer is a very painful thing. If you can get the reference of the upper Widget directly, it is very convenient to get the parameter held by the Widget.\n\n*   3\\. When the point triggering the update and the point to be updated are far away from the code.\n\n    Without the help of frameworks such as Redux, we usually encapsulate \\[the point that triggered the update] and \\[the point that was updated] in the smallest possible range (encapsulated in a StatefulWidget with the smallest range). However, there are always two predestined friends who are thousands of miles away. At this time, it is not very elegant to trigger a large range or even rebuild the entire Widget tree.\n\nHow can these three points be solved?\n\nIn Navigator's source code system, there are two key objects that provide global reference capabilities to the outside world, namely:` Navigator  `And` Overlay  `, with the help of`BuildContext`Of`ancestor*`Method lookup.\n\n`BuildContext`Yes`Element`Abstract class, so`BuildContext`The search is to traverse the Element tree to find the required elements.\n\nLet's see`BuildContext`What methods are provided:\n\n    ancestorInheritedElementForWidgetOfExactType ---  Find the nearest InheritedElement in the InheritedWidget up\n    inheritFromWidgetOfExactType --- Find the nearest InheritedWidget up\n    ancestorRenderObjectOfType --- lookup the nearest RenderObject of a given type\n    ancestorStateOfType --- look up the State object of the nearest StatefulWidget of the given type\n    ancestorWidgetOfExactType --- up to find the nearest widget of a given type\n    findRenderObject --- Find the current RenderObject down\n    rootAncestorStateOfType --- Look up the topmost State of a given type\n\n    visitAncestorElements (bool visitor (Element element )) --- traverse Ancestor up\n\nLooking up is relatively simple, just pass in the corresponding type, down`BuildContext`It also provides a way to traverse the child:\n\n    VisitChildElements (ElementVisitor visitor ) --- traverse child down\n\nTo` Overlay  `Static method`of`Method as an example (`Navigator`There are similar`of`Method), pass in the type object to be found` TypeMatcher  `, Look up to the nearest` OverlayState  `, make` Overlay  `No need to pass your own references down layer by layer, the underlying widget can be obtained anywhere` Overlay  `Refer to and call its method or property, which resolves`1``2`The problem:\n\n    class Overlay {\n    ...\n    static OverlayState of(BuildContext context, { Widget debugRequiredFor }) {\n        final OverlayState result = context.ancestorStateOfType(const TypeMatcher<OverlayState>());\n        ...\n        return result;\n    }\n    ...\n\nSo how can we inform the predestined friends who meet thousands of miles away to rebuild?` Overlay  `Also gives us a good example to`OverlayState`Of` insert  `Method as an example:\n\nPass` Overlay  `Static method`of`Get to`OverlayState`After reference, call` insert  `, its internal direct call`setState(() {}`Method modifies its own data content and triggers its own scope rebuild.\n\n    void insert(OverlayEntry entry, { OverlayEntry above }) {\n        entry._overlay = this;\n        setState(() {\n          final int index = above == null ? _entries.length : _entries.indexOf(above) + 1;\n          _entries.insert(index, entry);\n        });\n      }\n\nIn this way,`1``2``3`Point to have the corresponding solution, the development process may wish to consider using this way to optimize your code.\n\nHowever, traversing the Element tree to find references and operations is not an efficient and safe thing after all, so in some scenarios, the following trick can be considered: \"element autonomy.\"\n\n### Element autonomy\n\nThe best example still comes from` Overlay  `。\n\nIn traditional programming thinking, collections are responsible for storing elements, elements hold data, and a manager is responsible for operating collections and elements in collections.\n\n` OverlayState  `There are three ways to manipulate a collection:\n\n      void insert(OverlayEntry entry, { OverlayEntry above }) \n      void insertAll(Iterable<OverlayEntry> entries, { OverlayEntry above }) \n      void _remove(OverlayEntry entry) \n\nLimited by Flutter's declarative programming, object references are expensive to find, and the Manager implementation is not elegant enough in this scenario. So although`insert`Method still needs to pass` Overlay  `Static method`of`Find` OverlayState  `Called by reference. But`_remove`But it is a private method, which does not allow you to pass directly` OverlayState  `To call.\n\n`OverlayEntry`Delete only by`OverlayEntry`Do it yourself:\n\n    class OverlayEntry {\n      ...\n      void remove() {\n        final OverlayState overlay = _overlay;\n        _overlay = null;\n        if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n          SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n            overlay._remove(this);\n          });\n        } else {\n          overlay._remove(this);\n        }\n      }\n      ...\n\nThis programming method not only ensures the \"safety\" of elements, but also avoids the loss of searching in the tree.\n\nThe reason for safety is that the deletion of elements not only ends when they are deleted from the collection, but also a series of \"uninstallation\" and callbacks need to be executed. Element autonomy blocks the possibility of directly operating the collection to delete elements from the outside.\n\n### Private class wrapping: isolating logic from widgets\n\nIf you need to customize a widget, this widget holds multiple children internally, and these children are constantly changing. How would you maintain this list of children?\n\nCreate one directly`List<Widget>`Assemble? No, it's not elegant or safe!\n\nWe know that Widgets are the cornerstone of Flutter. After each Widget is run, it has infinite extensions. It may be short-lived and non-reusable and may exist for a long time. They can not only produce Element and RenderObject, but also include a complete life cycle and various callbacks within the system.\n\nCan you promise to take care of them?\n\nA hidden rule in the Flutter world is: the creation of Widegets, as far as possible only in the build method! Leave the creation and destruction of Widegets to the Flutter system for maintenance!\n\nSo how to do it?\n\nThe third example comes from` Overlay  `， ` Overlay  `The design is really good!\n\n` Overlay  `Internal also holds multiple children:`List<OverlayEntry>`, but`OverlayEntry`It is not a widget, it is just an ordinary Dart class. It holds the necessary attributes and some logic to create a widget.\n\nAnd` Overlay  `The widget that was actually created at build time is` _OverlayEntry  `：\n\n    class _OverlayEntry extends StatefulWidget {\n      _OverlayEntry(this.entry)\n        : assert(entry != null),\n          super(key: entry._key);\n\n      final OverlayEntry entry;\n\n      @override\n      _OverlayEntryState createState() => _OverlayEntryState();\n    }\n\n    class _OverlayEntryState extends State<_OverlayEntry> {\n      @override\n      Widget build(BuildContext context) {\n        return widget.entry.builder(context);\n      }\n\n      void _markNeedsBuild() {\n        setState(() { /* the state that changed is in the builder */ });\n      }\n    }\n\nCan see` _OverlayEntry  `Is a private class, its code is very simple, the construction method passed in a` OverlayEntry  `, build when executed is`entry.builder(context)`Method.\n\nSo: If you need to do frequent operations on a widget or widget collection, the recommended approach is to separate the logic and attributes, maintain an unchanged logical object, and let the widget build or rebuild according to the logical object. Try to avoid directly operating a widget and changing its internal attributes.\n\n## Help for practical application development after reading Navigator source code\n\nReading source code can often deepen the understanding of the system execution process, which may play a vital role in the future, but it may never be used. The uncertainty of this income and the dullness of source code reading often make most people flinch.\n\nSo at the end of the article, I briefly list some help for practical application development after reading the source code. Therefore, to increase your enthusiasm for source code learning.\n\n### Route dynamic monitoring\n\nAs the development complexity increases, you will definitely have the need to monitor route changes. If you are`MaterialApp`A little research will know that in building`MaterialApp`Can pass one`navigatorObservers`Parameters, probably like this:\n\n      Widget build(BuildContext context) {\n        return new MaterialApp(\n          navigatorObservers: [new MyNavigatorObserver()],\n          home: new Scaffold(\n            body: new MyPage(),\n          ),\n        );\n      }\n\n`navigatorObservers`Is a`List<NavigatorObserver>`Collection, which traverses the collection callback method whenever the navigator changes.\n\nEven if you don't know`MaterialApp`There is such an attribute in reading`NavigatorState`Source code,`pop`,`push`And other methods have the following code inside, knowing that the route change provides` observer  `Of:\n\n      @optionalTypeArgs\n      Future<T> push<T extends Object>(Route<T> route) {\n      \t...\n        for (NavigatorObserver observer in widget.observers)\n          observer.didPush(route, oldRoute);\n    \t...\n      }\n\nHere comes another question!\n\nA standard project will often`MaterialApp`The statement is at the top level, and most of the scenarios that need to monitor route changes are in the business code at the bottom. The stupid way is to pass the monitoring function layer by layer, but this is definitely an extremely painful process.\n\nA relatively elegant solution: dynamically add route listeners. How?\n\n`Navigator`And`NavigatorState`It does not directly expose the interface to add monitoring (is it not recommended by the government?), but if you look at the source code, you will know that the final callback`observers`By`Navigator`Hold`observers`Object, fortunately it is a public attribute.\n\nTherefore, the method of dynamically adding route monitoring can be implemented as follows:\n\n```\nMyNavigatorObserver myObserver = MyNavigatorObserver ();\n\n@Override\nVoid initState () {\nSuper.initState ();\n// recommend adding Observer dynamically when initState, rather than avoiding duplicate additions when build\nNavigator.of(context).widget.observers.add (myObserver);\n}\n\n@Override\nVoid dispose () {\nSuper.dispose ();\nRemove the wiretaps when //dispose\nNavigator.of(context).widget.observers.remove (myObserver);\n}\n\n```\n\n### Route Monitoring, Identification, Popup or Page\n\nOne of the more disturbing things is that in Flutter's world, both pages and popups are routed, so in the callback of route monitoring, the display and disappearance of popups will also trigger the callback.\n\nWhat if you want to identify whether the route in the callback is a pop-up window or a page? Is there any more elegant way?\n\nIf you have read the source code, you must remember that in`OverlayState`In the build method, through`OverlayEntry`Of`opaque`Attribute, all will enter`_Theatre`Component`entry`Distinguish for`onstageChildren`And`offstageChildren`。\n\n`opaque`What is the meaning? It determines whether the current Widget is a \"full screen opaque\" Widget, Page generally occupies the entire screen, so he is \"full screen opaque,\" pop-up window generally only occupies a part of the entire screen, so its \"full screen transparent.\"\n\nIf you have read the source code, you will know,`Route`Subclass`TransitionRoute`Hold`opaque`Properties, and all \"PageRoute\"`opaque=true`,\"PopupRoute\"`opaque=false`。\n\nThen the matter is very simple:\n\n    class MyNavigatorObserver extends NavigatorObserver {\n    @Override\n    Void didPush (Route < dynamic > route, Route < dynamic > previousRoute) {\n    If ((previousRoute is TransitionRoute ) && previousRoute.opaque ) {\n    // full screen opaque, usually a page\n    } else {\n    // full screen transparent, usually a pop-up window\n    }\n    }\n    }\n\nIt is worth noting that`opaque`The value does not completely mean that it is a page or a pop-up window, and there will always be special circumstances. Therefore, a more accurate understanding of this point is: identify` previousRoute  `Will occupy the entire screen, causing the original`route`Not visible.\n\n### Add Widget dynamically\n\nDue to Flutter's unique programming style, it is difficult to insert a widget into your code at any time.\n\nBut if you have read the source code, you already know it, in`MaterialApp`A pre-built` Overlay  `, Although it is for`Navigator`Service, but you can also use it:\n\n```\n// get the most recent Overlay to operate, if you don't add a custom one, usually the one of'Navigator '\nOverlay.of(context).insert (entry);\n\n// get the Overlay closest to the root to operate, usually the one of'Navigator '\n(Context .rootAncestorStateOfType (const TypeMatcher < OverlayState >()) as OverlayState).insert (entry);\n\n```\n\n### Easy-to-Tread Pit: Error Route Finding with Multiple Navigators Nested\n\nSuccess is also a Widget, failure is also a Widget. Everything is a Widget can have unlimited combinations, but it may also lead to abuse of Widgets.\n\n` MaterialApp  `The status in the Flutter world is similar to that in Android`Application` + `BaseActivity`. Theoretically there should only be the only one at the top of a project` MaterialApp  `, but Flutter does not restrict you from using multiple` MaterialApp  `。\n\nAlso`Navigator`Also a widget, you can also insert as many as you want anywhere in the tree`Navigator`。\n\nWhat's the problem? Suppose we have a widget tree like this:\n\n    - MaterialApp\n    \t- ...\n    \t\t-  Navigator\n    \t\t\t- ...\n    \t\t\t\t-  MaterialApp\n    \t\t\t\t-  Navigator\n    \t\t\t\t\t- ...\n    \t\t\t\t\t- MaterialApp\n\nGuess how many are in this widget tree` Navigator  `? Read the source code and you know every` MaterialApp  `Inside contains one` Navigator  `, So there are 5 in this tree` Navigator  `. So much` Navigator  `What is the problem?\n\nTake a look` Navigator  `Of`push`Method:\n\n    static Future<T> push<T extends Object>(BuildContext context, Route<T> route) {\n        return Navigator.of(context).push(route);\n      }\n\nThe default call is for a single parameter`Navigator.of(context)`Look,`of`Internal:\n\n    static NavigatorState of(\n        BuildContext context, {\n          bool rootNavigator = false,\n          bool nullOk = false,\n        }) {\n        final NavigatorState navigator = rootNavigator\n            ? context.rootAncestorStateOfType(const TypeMatcher<NavigatorState>())\n            : context.ancestorStateOfType(const TypeMatcher<NavigatorState>());\n        return navigator;\n    }\n\nBy default, the lookup is not the root node` NavigatorState  `, but the nearest one. This will cause you to be anywhere in the tree`push`Or`pop`It may not be the same operation` NavigatorState  `Object, they are not maintaining the same`route`Stack, which will cause a lot of problems.\n\nSo the appropriate approach is:\n\n*   1\\. Try your best to ensure that in your code,` MaterialApp  `There is only one in the project, and it is at the top of the widget tree.\n\n*   2\\. You can't guarantee that there is only one code`Navigator`, So for global page management, it is recommended to`push`Or`pop`Encapsulation, use`Navigator.of(context, rootNavigator:true)`Code to make sure you get the root`Navigator`。\n\nAnd for someone who really needs to get a tree`Navigator`Not the root`Navigator`, You have to strictly check`Navigator.of(context)`What you use`BuildContext`, make sure it is in the`Navigator`Below.\n\nA badcase:\n\n    class MyWidget extends StatelessWidget {\n      @override\n      Widget build(BuildContext context) {\n        return Stack(\n          children: <Widget>[\n            MyNavigator(), \n            GestureDetector(\n              onTap: (){\n                Navigator.of(context);\n              },\n              child: Text(\"ClickMe\"),\n            )\n          ],\n        );\n      }\n    }\n\n` MyNavigator  `We customize` Navigator  `, we need to click \"ClickMe\" to find in the tree` MyNavigator  `So, do you think you can find it?\n\nThe answer is no! Because we are based on` MyWidget  `Of` BuildContext  `（` BuildContext  `Is`Element`To look up in the Element tree, but obviously` MyWidget  `In` MyNavigator  `The upper level, of course, will not get the results you want ~\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "李兆轩",
"full_name": "李兆轩",
"email": "zhaoxuan.li@bytedance.com",
"employee_id": 1000008976,
"lark_id": "6611285200196337927",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/bbcb4c41-3454-4127-8899-dd7e73e1a42g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 11,
"digg_cnt": 107,
"lark_open_id": "8efd7597",
"auth": 0,
"department_name": "TikTok 研发-用户增长-客户端",
"intro": "",
"roleIds": [],
"score": 55,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 19,
"xid": "8b5350011ddafeb1361af53b2fad9832",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064992368",
"name": "TikTok 研发-用户增长-客户端",
"en_name": "TikTok Eng-Growth-Mobile"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Zhaoxuan Li",
"leader": {
"id": 5181199,
"name": "杜鹏",
"u_name": "杜鹏 (cooper.du)",
"email": "cooper.du@bytedance.com",
"employee_number": 5181199,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 5910293,
"entry_date": 1539302400
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "本文大纲：\n\n- <em>Flutter</em> 路由实现\n\t- <em>Flutter</em> 路由实现的底层依赖\n\t- <em>Flutter</em> 路由过程\n\t- *番外：[《<em>Flutter</em> 路由源码解析》](https://bytekm.bytedance.net...路由实现\n\n### <em>Flutter</em> 路由实现的底层依赖\n如果你对 <em>Flutter</em> 的Widget Tree有些了解。"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "【手把手学习flutter】flutter的widget简介",
"author_id": 1000013586,
"comment_count": 0,
"content": "## 【手把手学习flutter】flutter的widget简介\n\n### 一、前言\nFlutter中几乎所有的对象的都是1个Widget，与原生开发中的空间不同，flutter中widget概念更广泛，不仅仅是UI元素，还可以是一些**功能组件**，比如：手势检测的GestureDetector widget，APP主题数据传递的Theme等。原生开发中控件通常指的是UI元素。flutter中的组件，控件都是指的是widget，只是不同场景下的表述而已。\n\n### 二、一些概念\n#### 1、widget与element\n在flutter中，widget的功能：描述一个UI元素的配置数据。也就是说widget并不是表示最终绘制在设备屏幕上的**显示元素**，而它只描述元素的一个**配置数据**。\n\n实际上，Flutter真正的代表屏幕上显示元素的类是**Element**,也就说Widget是描述**Element的配置数据**，后边单独介绍element的类相关的。\n\n我们需要知道的是：Widget只是UI元素的一个配置数据，并且一个Widget可以对应多个Element。因为同一个Widget对象可以被添加到UI树的不同部分，而真正的渲染时，UI树的每一个Element节点都会对应一个Widget对象。\n\n总结一下：\n+ Widget实际上就是Element的配置数据，Widget树其实一个配置树，而真正的UI渲染树是由Element构成，可以认为Widget树就是指的是UI控件树或者UI渲染树。\n+ 一个Widget对象可以对应多个Element对象，根据同一份配置（Widget）可以创建多个实例Element。\n\n#### 2、Widget主要接口\n我们在dart源码看Widget类的声明：\n```\n@immutable\nabstract class Widget extends DiagnosticableTree {\n  const Widget({ this.key });\n  final Key key;\n\n  @protected\n  Element createElement();\n\n  @override\n  String toStringShort() {\n    return key == null ? '$runtimeType' : '$runtimeType-$key';\n  }\n\n  @override\n  void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n    super.debugFillProperties(properties);\n    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;\n  }\n\n  static bool canUpdate(Widget oldWidget, Widget newWidget) {\n    return oldWidget.runtimeType == newWidget.runtimeType\n        && oldWidget.key == newWidget.key;\n  }\n}\n```\n+ Widget类继承DiagnosticableTree，主要是提供调试信息。\n+ Key属性类似于react/vue中的key，主要决定是否在下一次build复用旧widget，决定条件在canUpdate()方法中。\n+ createElement(): 1个widget可以对应多个Element，flutter framework在构建UI树，会先调用此方法生成对用的节点Element对象，Framework隐式调用，开发中基本不会调用。\n+ debuugFillProperties复用父类的方法，主要是诊断树的一些特性。\n+ canUpdate是一个静态方法，主要用于Widget树重新build时复用旧的widget，要newWidget与oldWidget的runtimeType和key同时相等时就会用newWidget去更新Element对象的配置，否则就会创建新的Element。\n\n另外Widget类本身是一个抽象类，其中最核心的就是定义了createElement()接口，在Flutter开发中，我们一般都不用直接继承Widget类来实现一个新组件，相反，我们通常会通过继承StatelessWidget或StatefulWidget来间接继承Widget类来实现。StatelessWidget和StatefulWidget都是直接继承自Widget类，而这两个类也正是Flutter中非常重要的两个抽象类。\n\n\n#### 3、StatelessWidget\nStatelessWidget相对比较简单，它继承自Widget类，重写了createElement()方法：\n```\n@override\nStatelessElement createElement() => new StatelessElement(this);\n```\nStatelessElement 间接继承自Element类，与StatelessWidget相对应（作为其配置数据）。\n\nStatelessWidget用于不需要维护状态的场景，它通常在build方法中通过嵌套其它Widget来构建UI，在构建过程中会递归的构建其嵌套的Widget。\n\n\n#### 4、Context\nbuild方法中有一个context参数，是BuildContext类的一个实例，表示当前widget在widget树中的上下文，每一个widget都会对用一个context对象。实际上，context是当前widget树中位置中执行相关操作的钩子，比如它提供了当前widget开始向上遍历widget树以及按照widget类型查找父级widget的方法。\n\n```\n// Context\nclass Context1 extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text('Context测试-saucxs')),\n      body: Container(\n        child: Builder(builder: (context) {\n          // 在Widget树中向上查找最近的父级Scaffold widget\n          Scaffold scaffold = context.findAncestorWidgetOfExactType<Scaffold>();\n          // 直接返回 AppBar的title，此处实际上Text('Context测试')\n          return (scaffold.appBar as AppBar).title;\n        }),\n      ),\n    );\n  }\n}\n```\n效果如下：\n![images](http://static.chengxinsong.cn/image/flutter/flutter_context_1.jpg)\n\n#### 5、StatefulWidget\n和StatelessWidget一样，StatefulWidget也是继承Widget类，并重写了createElement()方法，不同的是返回的额Element对象并不相同，另外StatefulWidget类中添加一个新的接口createState()。\n\nstatefulWidget类的定义：\n```\nabstract class StatefulWidget extends Widget {\n  const StatefulWidget({ Key key }) : super(key: key);\n\n  @override\n  StatefulElement createElement() => new StatefulElement(this);\n\n  @protected\n  State createState();\n}\n```\n+ StatefulWidget间接继承Element类，与StatefulWidget相对应。\n+ createState()用于创建和Stateful widget相关的状态，它与Stateful widget的生命周期中可能被多次调用。例如，当一个Stateful widget同时插入到widget树的多个位置时，Flutter framework就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个StatefulElement对应一个State实例。\n\n#### 6、State\n一个StatefulWidget类会对应一个State类，State表示与其对应的StatefulWidget要维护的状态，State中的保存的状态信息可以是：\n+ 在widget构建时可以被同步读取。\n+ 在widget生命周期中可以改变，当State被改变时，可以手动调用其setState()方法通知Flutter framework 状态发生改变，flutter framework在收到消息后，会重新调用其build方法重新构建widget树，从而达到更新UI的目的。\n\nState中有2个常用的属性：\n+ widget。它表示与该State实例关联的widget实例，由Flutter framework动态设置。注意，这种关联不是永久的，因为在应用生命周期中，UI树上的某一个节点的widget实例在重新构建时可能会发生变化，单State实例只会在第一次插入到树中时被创建，当在重新构建时，如果widget被修改了，flutter framework 会动态设置State.widget为新的widget实例。\n+ context。StatefulWidget对应的BuildContext，作用同StatelessWidget的BuildContext。\n\n##### State生命周期\n理解掌握State的生命周期对flutter开发很重要，我们需要一个实例来演示State的生命周期。\n\n我们还是最初实现一个计数器widget，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应该继承StateWidget，代码如下：\n```\n// State生命周期\nclass CounterWidget extends StatefulWidget {\n  const CounterWidget({\n    Key key,\n    this.initValue: 0,\n  });\n\n  final int initValue;\n\n  @override\n  _CounterWidgetState createState() => new _CounterWidgetState();\n}\n\n// _CounterWidgetState\nclass _CounterWidgetState extends State<CounterWidget> {\n  int _counter;\n\n  @override\n  void initState() {\n    super.initState();\n    // 初始化状态\n    _counter=widget.initValue;\n    print('initState');\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    print('build');\n    return Scaffold(\n      body: Center(\n        child: FlatButton(\n          child: Text('$_counter'),\n          // 点击后计数器自增\n          onPressed: () => setState(() => ++_counter),\n        )\n      ),\n    );\n  }\n\n  @override\n  void didUpdateWidget(CounterWidget oldWidget) {\n    super.didUpdateWidget(oldWidget);\n    print('didUpdateWidget');\n  }\n\n  @override \n  void deactivate() {\n    super.deactivate();\n    print('deactivate');\n  }\n\n  @override\n  void dispose() {\n    super.dispose();\n    print('dispose');\n  }\n\n  @override\n  void reassemble() {\n    super.reassemble();\n    print('reassemble');\n  }\n\n  @override\n  void didChangeDependencies() {\n    super.didChangeDependencies();\n    print('didChangeDependencies');\n  }\n\n}\n```\n\n接下来，我们创建一个新路由，在新路由中，我们只显示一个CounterWidget：\n```\n // 注册路由表\n  routes: {\n    \"counter\": (context) {\n      return CounterWidget();\n    },\n    \"/\":(context) => MyHomePage(title: 'Fultter Demo'), //注册首页路由\n  },\n```\n\n我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：\n```\nReloaded 1 of 478 libraries in 485ms.\nI/flutter (22184): initState\nI/flutter (22184): didChangeDependencies\nI/flutter (22184): build\n```\n可以看到，在StatefulWidget插入到Widget树时首先initState方法会被调用。\n\n然后我们点击⚡️按钮热重载，控制台输出日志如下：\n```\nI/flutter (22184): reassemble\nI/flutter (22184): didUpdateWidget\nI/flutter (22184): build\nReloaded 0 of 478 libraries in 132ms.\n```\n可以看到此时initState 和didChangeDependencies都没有被调用，而此时didUpdateWidget被调用。\n\n接下来，我们在widget树中移除CounterWidget，将路由build方法改为：\n\n```\n \"counter\": (context) {\n    // return CounterWidget();\n    return Text(\"saucxs\");\n  },\n```\n\n然后热重载，日志如下：\n```\nI/flutter ( 22184): reassemble\nI/flutter ( 22184): deactive\nI/flutter ( 22184): dispose\n```\n\n我们可以看到，在CounterWidget从widget树中移除时，deactive和dispose会依次被调用。\n\n**State生命周期的总结：**\n+ initState：当Widget第一次插入到Widget树会被调用，对于每一个State对象，Flutter framework只会调用一次该回调，所以在在回调中做一些一次性的操作，如状态初始化，订阅子树的事件通知等。\n+ didChangeDependencies():当State对象的依赖发生变化时会被调用，比如：在之前build()中包含一个InheritedWidget，然后在之后的build()中InheritedWidget发生变化，那么此时InheritedWidget的子widget的didChangeDependencies()回调都会被调用。典型的场景是当系统语言Locale或者应用主题改变的时候，flutter framework会通知widget调用此回调。\n+ build():主要是用于构建Widget子树的。如下场景被调用：\n  - 在调用 initState() 之后\n  - 在调用 didUpdateWidget() 之后\n  - 在调用 setState() 之后\n  - 在调用 didChangeDependencies() 之后\n  - 在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其它位置之后。\n+ reassemble():此回调专门为开发调试而提供的，在热重载（hot reload）时候会被调用，此回调在release模式下永远不会被调用。\n+ didUpdateWidget():在widget重新构建时，Flutter framework会调用Widget.canUpdate来检测Widget树中同一位置的新旧节点，然后决定是否需要更新，如果Widget.canUpdate返回true会调用此回调，否则不调用。\n+ deactivate()：当State对象从树中被移除时，会调用此回调。在一些场景下，Flutter framework会将State对象重新插到树中，如包含此State对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey来实现）。如果移除后没有重新插入到树中则紧接着会调用dispose()方法。\n+ dispose()：当State对象从树中被永久移除时调用；通常在此回调中释放资源。\n\n![flutter的state生命周期](http://static.chengxinsong.cn/image/flutter/flutter_widget_2.jpg)\n\n### 三、总结\nFlutter提供了丰富的组件，在实际的开发中你可以根据需要随意使用他们，不必担心引用过多的组件库会让你的应用安装包变大，这不是web开发，dart在编译的时候只会编译你使用的代码。\n\n\n### 四、往期\n  + 5、[【手把手学习flutter】flutter的widget简介](https://study-tech.bytedance.net/articles/6833671017219489805)\n  + 4、[【手把手学习flutter】flutter的资源管理](https://study-tech.bytedance.net/articles/6831179322066206734)\n  + 3、[【手把手学习flutter】flutter的路由管理](https://study-tech.bytedance.net/articles/6827995410468962317)\n  + 2、[【flutter】手把手写flutter入门的例子（二）：无限滚动ListView添加交互和导航到新页面](https://study-tech.bytedance.net/articles/6821426320489054215)\n  + 1、[【flutter】手把手写flutter入门的例子：无限滚动ListView](https://study-tech.bytedance.net/articles/6815036523432378375)\n  ",
"ctime": 1591106606,
"mtime": 1622691178,
"commentable": 0,
"status": 0,
"dig_cnt": 2,
"collect_cnt": 1,
"cover_url": "https://tech-proxy.bytedance.net/tos/images/1591106597537_875d06f50cdb0f68f9e71b029c117cc4.png",
"brief": "",
"article_id": "6833671017219489805",
"draft_id": "6833721542946324494",
"view_cnt": 135,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "\\[Hand-in-hand learning flutter] Introduction to the widget of flutter\n",
"en_content": "## \\[Hand-in-hand learning flutter] Introduction to the widget of flutter\n\n### 1. Preface\n\nAlmost all objects in Flutter are 1 widget. Unlike the space in native development, the concept of widget in flutter is broader, not only UI elements, but also some**Functional components**For example: GestureDetector widget for gesture detection, Theme for APP theme data transfer, etc. In native development, controls usually refer to UI elements. Components and controls in flutter all refer to widgets, which are just expressions in different scenarios.\n\n### Ii. some concepts\n\n#### 1. Widget and element\n\nIn flutter, the function of the widget is to describe the configuration data of a UI element. In other words, the widget does not represent the final drawing on the device screen**Display element**, and it only describes one of the elements**Configuration data**。\n\nIn fact, the class that Flutter really represents on-screen display elements is**Element**So, Widget is a description**Element configuration data**, which is related to the class of the element separately.\n\nWhat we need to know is: Widget is only a configuration data of UI elements, and a Widget can correspond to multiple Elements. Because the same Widget object can be added to different parts of the UI tree, when rendering, each Element node of the UI tree will correspond to a Widget object.\n\nTo sum up:\n\n*   Widget is actually Element's configuration data. Widget tree is actually a configuration tree, and the real UI rendering tree is composed of Element. It can be considered that Widget tree refers to UI control tree or UI rendering tree.\n*   A widget object can correspond to multiple Element objects, and multiple instances of Element can be created according to the same configuration (widget).\n\n#### Widget main interface\n\nWe see the declaration of the widget class in the dart source code:\n\n    @immutable\n    abstract class Widget extends DiagnosticableTree {\n      const Widget({ this.key });\n      final Key key;\n\n      @protected\n      Element createElement();\n\n      @override\n      String toStringShort() {\n        return key == null ? '$runtimeType' : '$runtimeType-$key';\n      }\n\n      @override\n      void debugFillProperties(DiagnosticPropertiesBuilder properties) {\n        super.debugFillProperties(properties);\n        properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;\n      }\n\n      static bool canUpdate(Widget oldWidget, Widget newWidget) {\n        return oldWidget.runtimeType == newWidget.runtimeType\n            && oldWidget.key == newWidget.key;\n      }\n    }\n\n*   The Widget class inherits the DiagnosticableTree and mainly provides debugging information.\n*   The Key property is similar to the key in the react/vue, which mainly determines whether to reuse the old widget at the next build, and the determination condition is in the canUpdate () method.\n*   CreateElement (): 1 widget can correspond to multiple Elements. When the flutter framework is building a UI tree, it will first call this method to generate the Element object for the node used. Framework is implicitly called, which is basically not called in development.\n*   The method of debuugFillProperties reuses the parent class, mainly some features of the diagnostic tree.\n*   CanUpdate is a static method, mainly used to reuse the old widget when the Widget tree is rebuilt. If the newWidget is equal to the runtimeType and key of the oldWidget at the same time, the newWidget will be used to update the configuration of the Element object, otherwise a new Element will be created.\n\nIn addition, the Widget class itself is an abstract class, the core of which is the definition of the createElement () interface. In Flutter development, we generally do not directly inherit the Widget class to implement a new component. On the contrary, we usually Inherit the Widget class indirectly by inheriting the StatelessWidget or StatefulWidget. StatelessWidget and StatefulWidget are both directly inherited from the Widget class, and these two classes are also very important in Flutter. Two abstract classes.\n\n#### 3、StatelessWidget\n\nStatelessWidget is relatively simple. It inherits from the Widget class and overrides the createElement () method:\n\n    @override\n    StatelessElement createElement() => new StatelessElement(this);\n\nStatelessElement indirectly inherits from the Element class and corresponds to the StatelessWidget (as its configuration data).\n\nStatelessWidgets are used for scenarios that do not require state maintenance. It usually builds the UI by nesting other widgets in the build method, and its nested widgets will be built recursively during the build process.\n\n#### 4、Context\n\nThere is a context parameter in the build method, which is an instance of the BuildContext class. It represents the context of the current widget in the widget tree. Each widget will use a context object. In fact, context is a hook that performs related operations in the current widget tree. For example, it provides a method for the current widget to start traversing the widget tree upward and looking for the parent widget according to the widget type.\n\n    // Context\n    class Context1 extends StatelessWidget {\n    @Override\n    Widget build (BuildContext context) {\n    Scaffold return return (\n    AppBar: AppBar (title: Text ('Context Test-saucxs ')),\n    Body: Container (\n    Child: Builder (builder: (context) {\n    // look up the nearest parent Scaffold widget in the widget tree\n    Scaffold scaffold = context.findAncestorWidgetOfExactType< Scaffold >();\n    // directly return the title of the AppBar, where it is actually Text ('Context test')\n    Return (scaffold.appBar as AppBar).title;\n    }),\n    ),\n    );\n    }\n    }\n\nThe effect is as follows:\n![images](http://static.chengxinsong.cn/image/flutter/flutter_context\\_1.jpg)\n\n#### 5、StatefulWidget\n\nLike StatelessWidget, StatefulWidget also inherits the Widget class and overrides the createElement () method, except that the returned amount Element object is not the same. In addition, a new interface createState () is added to the StatefulWidget class.\n\nDefinition of the statefulWidget class:\n\n    abstract class StatefulWidget extends Widget {\n      const StatefulWidget({ Key key }) : super(key: key);\n\n      @override\n      StatefulElement createElement() => new StatefulElement(this);\n\n      @protected\n      State createState();\n    }\n\n*   The StatefulWidget indirectly inherits the Element class, corresponding to the StatefulWidget.\n*   CreateState () is used to create a Stateful widget-related state, which may be called multiple times in the life cycle of the Stateful widget. For example, when a Stateful widget is inserted into multiple locations in the widget tree at the same time, the Flutter framework will call this method to generate a separate State instance for each location. In fact, it is essentially a Stateful Element corresponding to a State instance.\n\n#### 6、State\n\nA StatefulWidget class corresponds to a State class. State represents the state to be maintained by its corresponding StatefulWidget. The saved state information in State can be:\n\n*   It can be read synchronously when the widget is built.\n*   It can be changed in the widget life cycle. When the State is changed, you can manually call its setState () method to notify the Flutter framework that the state has changed. After receiving the message, the flutter framework will call its build method again to rebuild the widget tree. To achieve the purpose of updating the UI.\n\nState has two common properties:\n\n*   Widget. It represents the widget instance associated with the State instance, which is dynamically set by the Flutter framework. Note that this association is not permanent, because the widget instance of a node in the UI tree may change during rebuilding during the application life cycle. A single State instance will only be created when it is first inserted into the tree. When rebuilding, if the widget is modified, the flutter framework will be dynamically set State.widget to a new widget instance.\n*   Context. The BuildContext corresponding to the StatefulWidget acts as the BuildContext of the StatelessWidget.\n\n##### State life cycle\n\nUnderstanding and mastering the state lifecycle is important for flutter development, and we need an example to demonstrate the state lifecycle.\n\nWe still initially implemented a counter widget. Click on it to add 1 to the counter. Since we want to save the numerical state of the counter, we should inherit the StateWidget. The code is as follows:\n\n    // State life cycle\n    class CounterWidget extends StatefulWidget {\n    CounterWidget ({\n    Key key,\n    InitValue: 0,\n    });\n\n    The final int initValue;\n\n    @Override\n    _CounterWidgetState createState () => new _CounterWidgetState ();\n    }\n\n    // _ CounterWidgetState\n    Class _CounterWidgetState extends State < CounterWidget > {\n    Int _counter;\n\n    @Override\n    Void initState () {\n    Super.initState ();\n    // initialization status\n    _counter= widget.initValue;\n    Print ('initState');\n    }\n\n    @Override\n    Widget build (BuildContext context) {\n    Print ('build');\n    Scaffold return return (\n    Body: Center (\n    FlatButton (child child)\n    Child: Text ('$_ counter '),\n    // counter increases after clicking\n    onPressed: () => setState (() => ++_ counter),\n    )\n    ),\n    );\n    }\n\n    @Override\n    void didUpdateWidget (CounterWidget oldWidget) {\n    Super.didUpdateWidget (oldWidget);\n    Print ('didUpdateWidget');\n    }\n\n    @Override\n    Void deactivate () {\n    Super.deactivate ();\n    Print ('deactivate');\n    }\n\n    @Override\n    Void dispose () {\n    Super.dispose ();\n    Print ('dispose');\n    }\n\n    @Override\n    Void reassemble () {\n    Super.reassemble ();\n    Print ('reassemble');\n    }\n\n    @Override\n    void didChangeDependencies () {\n    Super.didChangeDependencies ();\n    Print ('didChangeDependencies');\n    }\n\n    }\n\nNext, we create a new route, in which we display only one CounterWidget:\n\n    // registration routing table\n    The routes: {\n    \"Counter \": ( context) {\n    CounterWidget return return ();\n    },\n    \"/\":( context ) => MyHomePage (title: 'Fultter Demo '), // Registration Home Routing\n    },\n\nWe run the application and open the route page. After the new route page opens, a number 0 will appear in the center of the screen, and then the console log output:\n\n    Reloaded 1 of 478 libraries in 485ms.\n    I/flutter (22184): initState\n    I/flutter (22184): didChangeDependencies\n    I/flutter (22184): build\n\nAs you can see, the initState method is called first when the StatefulWidget is inserted into the Widget tree.\n\nThen we click the ⚡ ️ button to heat reload, and the console output log is as follows:\n\n    I/flutter (22184): reassemble\n    I/flutter (22184): didUpdateWidget\n    I/flutter (22184): build\n    Reloaded 0 of 478 libraries in 132ms.\n\nYou can see that neither initState nor didChangeDependencies are called at this time, while didUpdateWidget is called at this time.\n\nNext, we remove the CounterWidget from the widget tree and change the route build method to:\n\n     \"counter\": (context) {\n        // return CounterWidget();\n        return Text(\"saucxs\");\n      },\n\nThen hot reload, log as follows:\n\n    I/flutter ( 22184): reassemble\n    I/flutter ( 22184): deactive\n    I/flutter ( 22184): dispose\n\nAs you can see, when the CounterWidget is removed from the widget tree, deactive and dispose are called in turn.\n\n**State life cycle summary:**\n\n*   InitState: When the Widget is first inserted into the Widget tree, it will be called. For each State object, the Flutter framework will only call the callback once, so do some one-time operations in the callback, such as state initialization, Subscribe to the event notification of the subtree, etc.\n*   didChangeDependencies (): When the dependency of the State object changes, for example, if an InheritedWidget is included in the previous build (), and then the InheritedWidget changes in the subsequent build (), then the didChangeDependencies () callback of the InheritedWidget subwidget will be called. A typical scenario is when the system language Locale or application theme changes, the flutter framework will notify the widget to call this callback.\n*   Build (): Mainly used to build a Widget subtree. The following scenario is called:\n    *   After calling initState ()\n    *   After calling didUpdateWidget ()\n    *   After calling setState ()\n    *   After calling didChangeDependencies ()\n    *   After the State object is removed from one location in the tree (deactivate is called) and reinserted to another location in the tree.\n*   Reassemble (): This callback is specially provided for development debugging. It will be called during hot reload. This callback will never be called in release mode.\n*   didUpdateWidget (): When the widget is rebuilt, the Flutter framework calls Widget.canUpdate to detect new and old nodes in the same location in the Widget tree, and then decides whether an update is needed. If Widget.canUpdate returns true, this callback will be called, otherwise it will not be called.\n*   Deactivate (): This callback is called when a State object is removed from the tree. In some scenarios, the Flutter framework will reinsert the State object into the tree, such as when the subtree containing the State object moves from one position in the tree to another (which can be achieved with GlobalKey). If the State object is not reinserted into the tree after removal, the dispose () method is called immediately.\n*   Dispose (): Called when the State object is permanently removed from the tree; resources are usually released in this callback.\n\n![The flutter state lifecycle](http://static.chengxinsong.cn/image/flutter/flutter_widget\\_2.jpg)\n\n### III. Summary\n\nFlutter provides a wealth of components, in actual development you can use them as needed, don't worry about referencing too many component libraries will make your application installation package bigger, this is not web development, dart will only compile when compiling the code you use.\n\n### IV. Past periods\n\n*   5、[\\[Hand-in-hand learning flutter\\] Introduction to the widget of flutter](https://study-tech.bytedance.net/articles/6833671017219489805)\n*   4、[\\[Hand-in-hand learning flutter\\] flutter resource management](https://study-tech.bytedance.net/articles/6831179322066206734)\n*   3、[\\[Hand-in-hand learning flutter\\] flutter routing management](https://study-tech.bytedance.net/articles/6827995410468962317)\n*   2、[\\[Flutter\\] Handle handwritten flutter introduction example (2): Infinite scrolling ListView adds interaction and navigation to a new page](https://study-tech.bytedance.net/articles/6821426320489054215)\n*   1、[\\[Flutter\\] Handle handwritten flutter introduction example: infinite scrolling ListView](https://study-tech.bytedance.net/articles/6815036523432378375)\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "程新松",
"full_name": "程新松",
"email": "chengxinsong@bytedance.com",
"employee_id": 1000013586,
"lark_id": "6746382553587908877",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/27b1293b-83ed-44ab-ac12-8eb1228f4acg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 6,
"follower_count": 44,
"digg_cnt": 169,
"lark_open_id": "714fgfae",
"auth": 0,
"department_name": "Data-数据平台-前端-增长平台",
"intro": "STAY CURIOUS. STAY HUMBLE.",
"roleIds": [],
"score": 214,
"status": 1,
"answer_digg_cnt": 10,
"question_cnt": 0,
"answer_cnt": 1,
"is_follow": false,
"collect_cnt": 111,
"xid": "469d1ff5e6209e785e26cf0a1001621a",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 1,
"Hackathon": 1,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000065000198",
"name": "Data-数据平台-前端-增长平台",
"en_name": "Data-Data Platform-Front End-Growth Platform"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Xinsong Cheng",
"leader": {
"id": 9698995,
"name": "陈屹",
"u_name": "陈屹 (chenyi.arthur)",
"email": "chenyi.arthur@bytedance.com",
"employee_number": 9698995,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 3230538,
"entry_date": 1570752000
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
},
{
"id": 209,
"name": "Flutter / Dart",
"follow_count": 10,
"item_count": 21,
"en_name": "Flutter / Dart",
"icon": "",
"is_follow": false
},
{
"id": 1561,
"name": "Widget",
"follow_count": 0,
"item_count": 6,
"en_name": "Widget",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "## 【手把手学习<em>flutter</em>】<em>flutter</em>的widget简介\n\n### 一、前言\n<em>Flutter</em>中几乎所有的对象的都是1个Widget，与原生开发中的空间不同，<em>flutter</em>中widget概念更广泛...[<em>flutter</em>的state生命周期](http://static.chengxinsong.cn/image/<em>flutter</em>/<em>flutter</em>_widget_2.jpg)\n\n### 三、总结\n<em>Flutter</em>"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "【手把手学习flutter】flutter的资源管理",
"author_id": 1000013586,
"comment_count": 0,
"content": "## 【手把手学习flutter】flutter的资源管理\n\n### 一、前言\nFlutter App安装包中包含代码和assets(资源)两部分。assets是会打包到程序安装包中，可以在运行时候访问。\n\n常见的类型的assets包括静态数据、配置文件、图标和图片(jpeg,webpg,gif,png，bmp，wbmp)等。\n\n### 二、指定assets\nflutter使用pubspec.yaml文件来管理应用程序所需的资源，举个例子：\n\n```\nflutter:\n  assets:\n    - assets/my_icon.png\n    - assets/background.png\n```\n\nassets指定应包含在应用程序中的文件， 每个asset都通过相对于pubspec.yaml文件所在的文件系统路径来标识自身的路径。asset的声明顺序是无关紧要的，asset的实际目录可以是任意文件夹.\n\n在构建期间，Flutter将asset放置到称为 asset bundle 的特殊存档中，应用程序可以在运行时读取它们（但不能修改）。\n\n\n### 三、加载assets\n可以通过AssetBundle对象访问其asset 。有两种主要方法允许从Asset bundle中加载字符串或图片（二进制）文件。\n\n#### 1、加载文本assets\n+ 通过rootBundle 对象加载：每个Flutter应用程序都有一个rootBundle对象， 通过它可以轻松访问主资源包，直接使用package:flutter/services.dart中全局静态的rootBundle对象来加载asset即可。\n+ 通过 DefaultAssetBundle 加载：建议使用 DefaultAssetBundle 来获取当前BuildContext的AssetBundle。 这种方法不是使用应用程序构建的默认asset bundle，而是使父级widget在运行时动态替换的不同的AssetBundle，这对于本地化或测试场景很有用。\n\n#### 2、加载图片\n与原生开发相似，flutter可以为当前设备加载适合其分辨率的图片。\n\n##### (1)声明分辨率相关的图片assets\nAssetsImage可以将asset的请求逻辑映射到最接近当前设备像素比例（dpi）的asset。为了使这种映射起作用，必须根据特定的目录结构来保存asset：\n```\n…/image.png\n…/Mx/image.png\n…/Nx/image.png\n…etc.\n```\n\n其中M和N是数字标识符，对应于其中包含的图像的分辨率，也就是说，它们指定不同设备像素比例的图片。\n\n主资源默认对应于1.0倍的分辨率图片。看一个例子：\n\n```\n…/my_icon.png\n…/2.0x/my_icon.png\n…/3.0x/my_icon.png\n```\n\n在设备像素比率为1.8的设备上，.../2.0x/my_icon.png 将被选择。对于2.7的设备像素比率，.../3.0x/my_icon.png将被选择。\n\n如果未在Image widget上指定渲染图像的宽度和高度，那么Image widget将占用与主资源相同的屏幕空间大小。 也就是说，如果.../my_icon.png是72px乘72px，那么.../3.0x/my_icon.png应该是216px乘216px; 但如果未指定宽度和高度，它们都将渲染为72像素×72像素（以逻辑像素为单位）。\n\npubspec.yaml中asset部分中的每一项都应与实际文件相对应，但主资源项除外。当主资源缺少某个资源时，会按分辨率从低到高的顺序去选择 ，也就是说1x中没有的话会在2x中找，2x中还没有的话就在3x中找。\n\n##### (2)显示图片\n要显示图片需要使用AssetImage类。\n\n比如，我们可以从上面声明中加载背景图片\n\n```\nclass BgPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return new DecoratedBox(\n    decoration: new BoxDecoration(\n      image: new DecorationImage(\n        image: new AssetImage('asset/images/bg.jpeg'),\n      ),\n    ),\n  );\n  }\n}\n```\n\n需要注意的是：AssetImage并非是widget，实际上是一个ImageProvider，有时候你希望得到一个显示图片的widget，这样你可以使用Image.asset()方法，比如：\n\n```\nclass BgPage2 extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Image.asset('asset/images/bg.jpeg');\n  }\n}\n```\n\n使用默认的 asset bundle 加载资源时，内部会自动处理分辨率等，这些处理对开发者来说是无感知的。\n\n\n### 四、特定平台assets\n上面的资源都是flutter应用中的，这些资源只有在Flutter框架运行之后才能使用。\n\n如果要给我们的应用设置APP图标或者添加启动图，那我们必须使用「特定平台的assets」。\n\n#### 1、设置App的Icon\n更新Flutter应用程序启动图标的方式与在本机Android或iOS应用程序中更新启动图标的方式相同。\n\n##### (1)Android\n在Flutter项目的根目录中，导航到.../android/app/src/main/res目录，里面包含了各种资源文件夹（如mipmap-hdpi已包含占位符图像“ic_launcher.png”）。只需按照[Android开发人员指南](https://material.io/design/iconography/product-icons.html)中的说明， 将其替换为所需的资源，并遵守每种屏幕密度（dpi）的建议图标大小标准。\n\n> 注意: 如果您重命名.png文件，则还必须在您AndroidManifest.xml的<application>标签的android:icon属性中更新名称。\n\n\n##### (2)IOS\n在Flutter项目的根目录中，导航到.../ios/Runner。该目录中Assets.xcassets/AppIcon.appiconset已经包含占位符图片（见图2-9）， 只需将它们替换为适当大小的图片，保留原始文件名称。\n\n\n#### 2、更新启动页\n在Flutter框架加载时Flutter会使用本地平台机制启动页。此启动页「将持续到Flutter」渲染应用程序的第一帧时。\n\n需要注意的地方：如果不在应用程序的main()方法中调用runApp函数。或者说，不调用window.render去响应window.onDrawFrame的话，启动屏幕将永远持续显示。\n\n##### (1)Android\n要将启动屏幕添加到Flutter应用程序，导航到.../android/src/main。\n\n在res/drawable/launch_background.xml，通过自定义drawable来实现自定义启动页面。\n\n![项目结构](http://static.chengxinsong.cn/image/flutter/flutter_asset_1.jpg)\n\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<!-- Modify this file to customize your launch splash screen -->\n<layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item android:drawable=\"@android:color/white\" />\n\n    <!-- You can insert your own image assets here -->\n    <item>\n        <bitmap\n            android:gravity=\"center\"\n            android:src=\"@mipmap/bg\" />\n    </item>\n</layer-list>\n```\n![项目结构](http://static.chengxinsong.cn/image/flutter/flutter_asset_2.jpg)\n\n\n##### (2)IOS\n要将图片添加到启动屏幕（splash screen）的中心，请导航至.../ios/Runner。在Assets.xcassets/LaunchImage.imageset， 拖入图片，并命名为LaunchImage.png、LaunchImage@2x.png、LaunchImage@3x.png。 如果你使用不同的文件名，那您还必须更新同一目录中的Contents.json文件，图片的具体尺寸可以查看苹果官方的标准。\n\n您也可以通过打开Xcode完全自定义storyboard。在Project Navigator中导航到Runner/Runner然后通过打开Assets.xcassets拖入图片，或者通过在LaunchScreen.storyboard中使用Interface Builder进行自定义。\n  \n### 五、往期\n  + 4、[【手把手学习flutter】flutter的资源管理](https://study-tech.bytedance.net/articles/6831179322066206734)\n  + 3、[【手把手学习flutter】flutter的路由管理](https://study-tech.bytedance.net/articles/6827995410468962317)\n  + 2、[【flutter】手把手写flutter入门的例子（二）：无限滚动ListView添加交互和导航到新页面](https://study-tech.bytedance.net/articles/6821426320489054215)\n  + 1、[【flutter】手把手写flutter入门的例子：无限滚动ListView](https://study-tech.bytedance.net/articles/6815036523432378375)\n  ",
"ctime": 1590507955,
"mtime": 1622798986,
"commentable": 0,
"status": 0,
"dig_cnt": 1,
"collect_cnt": 0,
"cover_url": "https://tech-proxy.bytedance.net/tos/images/1590507947351_52fedf9caf95c76ba8d705b1bffd2475.png",
"brief": "",
"article_id": "6831179322066206734",
"draft_id": "6831167703554719757",
"view_cnt": 78,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "\\[Hand-in-hand learning flutter] flutter resource management\n",
"en_content": "## \\[Hand-in-hand learning flutter] flutter resource management\n\n### 1. Preface\n\nThe Flutter App installation package contains both code and assets (resources). Assets are packaged into the program installation package and can be accessed at runtime.\n\nCommon types of assets include static data, configuration files, icons and images (jpeg, webpg, gif, png, bmp, wbmp), etc.\n\n### II. Designated assets\n\nFlutter uses pubspec.yaml files to manage the resources needed by the application, for example:\n\n    flutter:\n      assets:\n        - assets/my_icon.png\n        - assets/background.png\n\nAssets specifies the files that should be included in the application, and each asset identifies its own path by the file system path relative to the pubspec.yaml file. The order of asset declaration is irrelevant, and the actual directory of the asset can be any folder.\n\nDuring build, Flutter places the assets in a special archive called an asset bundle that the application can read (but not modify) at runtime.\n\n### Loading assets\n\nIts asset can be accessed through an AssetBundle object. There are two main ways to allow character string or picture (binary) files to be loaded from the Asset bundle.\n\n#### Load text assets\n\n*   Loading through rootBundle objects: Each Flutter application has a rootBundle object, through which you can easily access the main resource package, and directly use the global static rootBundle object in the package:flutter/services.dart to load the asset.\n*   Loading via DefaultAssetBundle: It is recommended to use DefaultAssetBundle to get the current BuildContext AssetBundle. Instead of using the default asset bundle built by the application, this approach allows the parent widget to dynamically replace different AssetBundle at runtime, which is useful for localization or test scenarios.\n\n#### 2. Load the picture\n\nSimilar to native development, flutter can load images for the current device that suit its resolution.\n\n##### (1) Declare resolution-related picture assets\n\nAssetsImage can map the request logic of an asset to the asset closest to the current device pixel ratio (dpi). For this mapping to work, the asset must be stored according to a specific directory structure:\n\n    …/image.png\n    …/Mx/image.png\n    …/Nx/image.png\n    …etc.\n\nWherein M and N are numeric identifiers, corresponding to the resolution of the image contained therein, that is, they specify different device pixel ratios of the picture.\n\nThe main resource corresponds to a 1.0-fold resolution picture by default. Look at an example:\n\n    …/my_icon.png\n    …/2.0x/my_icon.png\n    …/3.0x/my_icon.png\n\nOn devices with a device pixel ratio of 1.8, .../2.0x/my_icon.png will be selected. For a device pixel ratio of 2.7, .../3.0x/my_icon.png will be selected.\n\nIf the width and height of the rendered image are not specified on the Image widget, then the Image widget will occupy the same screen space size as the main resource. That is, if the .../my_icon.png is 72px by 72px, then the .../3.0x/my_icon.png should be 216px by 216px; but if the width and height are not specified, they will both be rendered as 72 pixels × 72 pixels (in logical pixels).\n\nEach item in the asset section of the pubspec.yaml should correspond to the actual file, except for the main resource item. When the main resource lacks a resource, it will be selected in the order of resolution from low to high, that is to say, if it is not in 1x, it will be found in 2x, and if it is not in 2x, it will be found in 3x.\n\n##### (2) Display picture\n\nYou need to use the AssetImage class to display images.\n\nFor example, we can load the background image from the above statement\n\n    class BgPage extends StatelessWidget {\n      @override\n      Widget build(BuildContext context) {\n        return new DecoratedBox(\n        decoration: new BoxDecoration(\n          image: new DecorationImage(\n            image: new AssetImage('asset/images/bg.jpeg'),\n          ),\n        ),\n      );\n      }\n    }\n\nIt should be noted that AssetImage is not a widget, but actually an ImageProvider. Sometimes you want to get a widget that displays pictures, so you can use the Image.asset () method, such as:\n\n    class BgPage2 extends StatelessWidget {\n      @override\n      Widget build(BuildContext context) {\n        return Image.asset('asset/images/bg.jpeg');\n      }\n    }\n\nWhen using the default asset bundle to load resources, internal processing will be automatically processed, such as resolution, which is imperceptible to developers.\n\n### Platform-specific assets\n\nThe above resources are all in the flutter application, and these resources can only be used after the Flutter framework runs.\n\nIf you want to set the APP icon or add a startup diagram to our application, then we must use \"platform-specific assets.\"\n\n#### 1. Set the Icon of the App\n\nUpdate the Flutter app startup icon the same way you update the startup icon in a native Android or iOS app.\n\n##### (1)Android\n\nIn the root directory of the Flutter project, navigate to the .../android/app/src/main/res directory, which contains various resource folders (such as mipmap-hdpi already contains placeholder images \"ic_launcher.png ”)｡ just follow[Android Developer Guide](https://material.io/design/iconography/product-icons.html)Replace it with the required resources and adhere to the recommended icon size criteria for each screen density (dpi).\n\n> Note: If you rename the .png file, you must also AndroidManifest.xml<application>Update the name in the android: icon property of the label.\n\n##### (2)IOS\n\nIn the root directory of the Flutter project, navigate to the .../ios/Runner. The Assets.xcassets/AppIcon appiconset in this directory already contains placeholder pictures (see Figure 2-9). Simply replace them with appropriately sized pictures and keep the original file name.\n\n#### 2. Update the startup page\n\nWhen the Flutter framework loads, Flutter will use the local platform mechanism to start the page. This start page \"will last until Flutter\" renders the first frame of the application.\n\nNote: If you do not call the runApp function in the main () method of the application. In other words, if you do not call the window.render to respond to window.onDrawFrame, the startup screen will continue to display forever.\n\n##### (1)Android\n\nTo add the startup screen to the Flutter application, navigate to the .../android/src/main.\n\nres/drawable/launch_background.xml, customize the startup page by customizing drawable.\n\n![Project structure](http://static.chengxinsong.cn/image/flutter/flutter_asset\\_1.jpg)\n\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <!-- Modify this file to customize your launch splash screen -->\n    <layer-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n        <item android:drawable=\"@android:color/white\" />\n\n        <!-- You can insert your own image assets here -->\n        <item>\n            <bitmap\n                android:gravity=\"center\"\n                android:src=\"@mipmap/bg\" />\n        </item>\n    </layer-list>\n\n![Project structure](http://static.chengxinsong.cn/image/flutter/flutter_asset\\_2.jpg)\n\n##### (2)IOS\n\nTo add a picture to the center of the splash screen, navigate to the .../ios/Runner. In Assets.xcassets/LaunchImage, drag in the picture and name it LaunchImage.png, LaunchImage@2x.png, LaunchImage@3x.png. If you use a different filename, you must also update the Contents.json files in the same directory. The specific size of the picture can be viewed in Apple's official standards.\n\nYou can also fully customize the storyboard by opening Xcode. Navigate to the Runner/Runner in Project Navigator and drag in the picture by opening Assets.xcassets, or by using Interface Builder in LaunchScreen.storyboard.\n\n### V. Past periods\n\n*   4、[\\[Hand-in-hand learning flutter\\] flutter resource management](https://study-tech.bytedance.net/articles/6831179322066206734)\n*   3、[\\[Hand-in-hand learning flutter\\] flutter routing management](https://study-tech.bytedance.net/articles/6827995410468962317)\n*   2、[\\[Flutter\\] Handle handwritten flutter introduction example (2): Infinite scrolling ListView adds interaction and navigation to a new page](https://study-tech.bytedance.net/articles/6821426320489054215)\n*   1、[\\[Flutter\\] Handle handwritten flutter introduction example: infinite scrolling ListView](https://study-tech.bytedance.net/articles/6815036523432378375)\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "程新松",
"full_name": "程新松",
"email": "chengxinsong@bytedance.com",
"employee_id": 1000013586,
"lark_id": "6746382553587908877",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/27b1293b-83ed-44ab-ac12-8eb1228f4acg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 6,
"follower_count": 44,
"digg_cnt": 169,
"lark_open_id": "714fgfae",
"auth": 0,
"department_name": "Data-数据平台-前端-增长平台",
"intro": "STAY CURIOUS. STAY HUMBLE.",
"roleIds": [],
"score": 214,
"status": 1,
"answer_digg_cnt": 10,
"question_cnt": 0,
"answer_cnt": 1,
"is_follow": false,
"collect_cnt": 111,
"xid": "469d1ff5e6209e785e26cf0a1001621a",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 1,
"Hackathon": 1,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000065000198",
"name": "Data-数据平台-前端-增长平台",
"en_name": "Data-Data Platform-Front End-Growth Platform"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Xinsong Cheng",
"leader": {
"id": 9698995,
"name": "陈屹",
"u_name": "陈屹 (chenyi.arthur)",
"email": "chenyi.arthur@bytedance.com",
"employee_number": 9698995,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 3230538,
"entry_date": 1570752000
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "## 【手把手学习<em>flutter</em>】<em>flutter</em>的资源管理\n\n### 一、前言\n<em>Flutter</em> App安装包中包含代码和assets(资源)两部分。...#### 2、更新启动页\n在<em>Flutter</em>框架加载时<em>Flutter</em>会使用本地平台机制启动页。此启动页「将持续到<em>Flutter</em>」渲染应用程序的第一帧时。"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"video_info": {
"id_type": 24,
"item_id": "6844026091242258440",
"create_id": 1000004678,
"title": "首届Flutter技术沙龙-带你走近Flutter",
"description": "移动跨平台技术Flutter的深耕与探讨，题材丰富，来自西瓜视频、好好学习、移动平台部的5位讲师，深度讲解Flutter技术，带你领略下一代跨平台技术的魅力。",
"url": "v02313bd0000bln5tlaj2borkr2c4flg",
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1PZW3cxSNN95ZqKJD7YvVxnNiwrBPTLeg/view?usp=sharing"
},
"cover": "https://p9-tt.bytecdn.cn/origin/tos-cn-i-0000/1923e337968f4d10b904793c3c9e84e6",
"status": 0,
"digg_cnt": 6,
"view_cnt": 133,
"collect_cnt": 99,
"comment_cnt": 0,
"point_score": 0,
"ctime": 1567519916,
"mtime": 1621760332,
"tag": 100,
"video_status": 1,
"set_id": "0",
"content_mtime": 1567519916,
"duration": 2093,
"original": 0
},
"author": {
"name": "王丛林",
"full_name": "王丛林",
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"lark_id": "6628001948719120644",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 3,
"follower_count": 76,
"digg_cnt": 311,
"lark_open_id": "6cd9ee19",
"auth": 0,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "一块儿橡皮玩一天～",
"roleIds": [],
"score": 1162,
"status": 1,
"answer_digg_cnt": 5,
"question_cnt": 5,
"answer_cnt": 3,
"is_follow": false,
"collect_cnt": 213,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Conglin Wang",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 8506729,
"entry_date": 1543190400
},
"owners": [
{
"name": "袁辉辉",
"full_name": "袁辉辉",
"email": "yuanhuihui@bytedance.com",
"employee_id": 1000008607,
"lark_id": "6687750276985651469",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da730014af521a367fed~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 71,
"digg_cnt": 199,
"lark_open_id": "c17e7gb9",
"auth": 1,
"department_name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"intro": "Gityuan",
"roleIds": [
1
],
"score": 358,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 65,
"xid": "7783babcb9a649cb74e823d99fa102b1",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064983059",
"name": "产品研发和工程架构部-Client Infrastructure-Flutter Infra",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Flutter Infra"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Huihui Yuan",
"leader": {
"id": 7937698,
"name": "朱元硕",
"u_name": "朱元硕 (zhuyuanshuo)",
"email": "zhuyuanshuo@bytedance.com",
"employee_number": 7937698,
"en_name": ""
},
"expert_category_ids": [
3
],
"people_id": 9761123,
"entry_date": 1557100800
}
],
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 1026,
"name": "基础技术",
"follow_count": 36,
"item_count": 38,
"en_name": "Basic tech",
"icon": "",
"is_follow": false
},
{
"id": 1715,
"name": "首届Flutter技术沙龙",
"follow_count": 1,
"item_count": 5,
"en_name": "The first Flutter tech salon",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"highlight": {
"content": "移动跨平台技术<em>Flutter</em>的深耕与探讨，题材丰富，来自西瓜视频、好好学习、移动平台部的5位讲师，深度讲解<em>Flutter</em>技术，带你领略下一代跨平台技术的魅力。"
},
"item_set_info": {
"id": 14,
"item_id": "6897931266113732622",
"id_type": 39,
"title": "首届Flutter技术沙龙 系列分享",
"brief": "首届Flutter技术沙龙 系列分享",
"collect_cnt": 0,
"status": 0,
"ctime": 1606050205,
"mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606050184615_362ddf9c81b6bbfb6275df912e205867.png",
"tag": 1,
"item_list": [
{
"item_id": "6844026091242258440",
"id_type": 24
},
{
"item_id": "6844026093268107278",
"id_type": 24
},
{
"item_id": "6844026092777373703",
"id_type": 24
},
{
"item_id": "6844026091636523022",
"id_type": 24
},
{
"item_id": "6844026092211159054",
"id_type": 24
}
],
"content_mtime": 1622714447
},
"is_digg": false,
"is_collect": false,
"id_type": 24
},
{
"article_info": {
"title": "Flutter适配夜间模式",
"author_id": 1000013394,
"comment_count": 0,
"content": "> 夜间模式（Dark Mode），也被称为暗黑模式或深色模式，是一种高对比度，或者反色模式的显示模式，开启之后在夜间可以缓解疲劳，更易于阅读，同时也能在一定程度上达到省电的效果。苹果方面有表示，明年3月份还不适配深色模式的App都要从App Store下架\n\n# 夜间模式跟随系统\n使用`MaterialApp`的`darkTheme`选项，可以很方便地适配跟随系统的DarkMode：\n\n```dart\nMaterialApp( \n    theme: ThemeData( \n        brightness: Brightness.light, \n        primaryColor: Colors.blue, \n    ), \n    darkTheme: ThemeData( \n        brightness: Brightness.dark, \n    ),\n);\n```\n也可直接写做\n\n```dart\ndarkTheme: ThemeData.dark()\n```\n- 这种方式是自动跟随iOS/Android的系统设置来切换的，无需用户再单独设置\n\n# 手动开启夜间模式\n上述的跟随系统自动切换暗黑模式的体验可能并不是很好，比如用户不喜欢夜间模式或者App的夜间模式配色适配并不是很好，这就会导致用户无法手动控制app的夜间模式或者只能关闭系统的设置。因此我们可以增加手动控制以及跟随系统的选项，让用户选择是否开启以及开启的方式。\n\n## 保存用户配置\n在flutter中可以使用[shared_preferences](https://pub.dev/packages/shared_preferences)来保存用户的配置数据，具体使用方法详见：[shared_preferences](https://github.com/flutter/plugins/tree/master/packages/shared_preferences#usage)使用\n\n## 状态管理\n主题的手动切换是影响全局的，如果通过常规的数据流向很难做到。常见的几种状态管理：\n- [InheritedWidget](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html)\n- [Scoped model](https://pub.dev/packages/scoped_model)\n- [BLoC](https://github.com/felangel/bloc)\n- [Redux](https://github.com/brianegan/flutter_redux)\n- [Provider](https://pub.dev/packages/provider)\n\n[Provider](https://pub.dev/packages/provider)是Google I/O 2019大会宣布的现在官方推荐的状态管理方式，我们需要在设置页里面通过用户设置，把变更状态共享给其他Widget，这里采用[Provider](https://pub.dev/packages/provider)这种方式来实现状态共享。\n\n## 通用夜间模式Provider Model类\n\n```dart\nimport 'package:flutter/foundation.dart';\nimport 'package:shared_preferences/shared_preferences.dart';\n\nclass DarkModeModel with ChangeNotifier {\n  /// 夜间模式 0: 关闭 1: 开启 2: 随系统\n  int _darkMode;\n\n  static const Map<int, String> darkModeMap = {\n    0: \"关闭\",\n    1: \"开启\",\n    2: \"跟随系统\"\n  };\n\n  static const String STORE_KEY = 'darkMode';\n\n  SharedPreferences _prefs;\n\n  int get darkMode => _darkMode;\n\n  DarkModeModel() {\n    _init();\n  }\n\n  void _init() async {\n    this._prefs = await SharedPreferences.getInstance();\n    int localMode = this._prefs.getInt(STORE_KEY);\n    changeMode(localMode ?? 0);\n  }\n\n  void changeMode(int darkMode) async {\n\n    _darkMode = darkMode;\n\n    notifyListeners();\n\n    SharedPreferences prefs = this._prefs ?? (await SharedPreferences.getInstance());\n\n    await prefs.setInt(STORE_KEY, darkMode);\n  }\n}\n```\n\n## MaterialApp修改\n如果手动控制是否开启夜间模式，可以设置`MaterialApp`的`theme`选项为`ThemeData.dark()`\n\n```dart\ntheme: ThemeData.dark()\n```\n\n因为需要同时保留随系统自动切换与手动切换，而`darkTheme`选项和`theme`又有冲突，所以这里需要根据`darkModeModel.darkMode`的取值来渲染不同的`MaterialApp`，如果是手动模式再根据`darkModeModel.darkMode`的取值来渲染不同的`theme`。\n\n```dart\nMultiProvider(\n  providers: [\n    ChangeNotifierProvider(builder: (_) => DarkModeModel())\n  ],\n  child: Consumer<DarkModeModel>(\n    builder: (context, darkModeModel, _) {\n      return darkModeModel.darkMode == 2 \n        ? MaterialApp(\n            title: '特效君',\n            theme: ThemeData(\n              primarySwatch: Colors.blue,\n            ),\n            darkTheme: ThemeData.dark(),\n              home: MainPage(title: '特效君'),\n            ) \n        : MaterialApp(\n            title: '特效君',\n            theme: darkModeModel.darkMode == 1 \n              ? ThemeData.dark()\n              : ThemeData(\n                  primarySwatch: Colors.blue,\n                ),\n            home: MainPage(title: '特效君'),\n          );\n    },\n  ),\n)\n```\n\n## 效果\n这样我们就可以给用户提供自动跟随系统切换以及手动控制的选项了，效果如图：\n\n<p class=\"img-tip\" data-str=\"跟随系统开启夜间模式\"><img src=\"https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/7990e8790d894cbd93ce50db2cbd76f0~noop.png\" height=\"754\" width=\"772\"/></p>\n<p class=\"img-tip\" data-str=\"手动开启关闭夜间模式\"><img src=\"https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/3bf8c98403cb46549ddf0032944c2f7f~noop.png\" height=\"676\" width=\"782\"/></p>\n\n\n\n\n\n\n\n\n\n\n\n",
"ctime": 1574218318,
"mtime": 1620355183,
"commentable": 0,
"status": 0,
"dig_cnt": 1,
"collect_cnt": 0,
"cover_url": "",
"brief": "",
"article_id": "11444",
"draft_id": "6920191455235407886",
"view_cnt": 1528,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "Flutter adapted to night mode\n",
"en_content": "> Dark Mode, also known as Dark Mode or Dark Mode, is a high-contrast or anti-color display mode. After being turned on, it can relieve fatigue at night, make it easier to read, and at the same time achieve a certain degree of power saving. Apple has said that all apps that are not suitable for dark mode in March next year will be removed from the App Store\n\n# Night mode follow system\n\nUse`MaterialApp`Of`darkTheme`Option to easily adapt to DarkMode following the system:\n\n```dart\nMaterialApp( \n    theme: ThemeData( \n        brightness: Brightness.light, \n        primaryColor: Colors.blue, \n    ), \n    darkTheme: ThemeData( \n        brightness: Brightness.dark, \n    ),\n);\n```\n\nCan also be written directly\n\n```dart\ndarkTheme: ThemeData.dark()\n```\n\n*   This method is automatically switched according to the system settings of the iOS/Android, and there is no need for the user to set it separately\n\n# Manual night mode\n\nThe above-mentioned experience of automatically switching the dark mode of the following system may not be very good. For example, the user does not like the night mode or the color matching of the app's night mode is not very good, which will cause the user to be unable to manually control the night mode of the app or can only turn off the system settings. Therefore, we can add the options of manual control and following the system, allowing the user to choose whether to turn it on and how to turn\n\n## Save user configuration\n\nCan be used in flutter[shared_preferences](https://pub.dev/packages/shared_preferences)To save the user's configuration data, see:[shared_preferences](https://github.com/flutter/plugins/tree/master/packages/shared_preferences#usage)Use\n\n## State management\n\nThe manual switching of topics affects the whole world, which is difficult to do if it is done through regular data flow. Several common state management:\n\n*   [InheritedWidget](https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html)\n*   [Scoped model](https://pub.dev/packages/scoped_model)\n*   [BLoC](https://github.com/felangel/bloc)\n*   [Redux](https://github.com/brianegan/flutter_redux)\n*   [Provider](https://pub.dev/packages/provider)\n\n[Provider](https://pub.dev/packages/provider)It is the official recommended state management method announced by Google I/O 2019 conference. We need to share the change state to other widgets through user settings in the settings page. Here we use[Provider](https://pub.dev/packages/provider)This way to achieve state sharing.\n\n## Universal Night Mode Provider Model Class\n\n```dart\nImport package:flutter/foundation.dart\nImport package:shared_preferences/shared_preferences.dart\n\nclass DarkModeModel with ChangeNotifier {\n/// Night Mode 0: Off 1: On 2: With System\nInt _darkMode;\n\nStatic const Map < int, String > darkModeMap = {\n0: \"Close,\"\n1: \"On,\"\n2: \"Follow the system\"\n};\n\nstatic const String STORE_KEY = 'darkMode';\n\nSharedPreferences _prefs;\n\nInt get darkMode => _ darkMode;\n\nDarkModeModel () {\n_init ();\n}\n\nVoid _init () async {\nthis._prefs = await SharedPreferences.getInstance ();\nInt localMode =_prefs (STORE_KEY);\nchangeMode (localMode?? 0);\n}\n\nVoid changeMode (int darkMode) async {\n\n_darkMode= darkMode;\n\nNotifyListeners ();\n\nSharedPreferences prefs = this._prefs ?? (await SharedPreferences.getInstance ());\n\nawait prefs.setInt (STORE_KEY, darkMode);\n}\n}\n```\n\n## MaterialApp Modifications\n\nIf you manually control whether to turn on the night mode, you can set`MaterialApp`Of`theme`Option is`ThemeData.dark()`\n\n```dart\ntheme: ThemeData.dark()\n```\n\nBecause it is necessary to keep the automatic switching and manual switching with the system at the same time, and`darkTheme`Options and`theme`There are conflicts again, so it needs to be based on`darkModeModel.darkMode`To render different`MaterialApp`, If it is manual mode then according to`darkModeModel.darkMode`To render different`theme`。\n\n```dart\nMultiProvider (\nProviders: [\nChangeNotifierProvider (builder: ( _ ) => DarkModeModel ())\n],\nChild: Consumer < DarkModeModel > (\nBuilder: (context, darkModeModel, _ ) {\nReturn darkModeModel.darkMode == 2\n? MaterialApp (\nTitle: 'Special Effects King',\nThemeData (theme theme)\nPrimary Swatch: Colors.blue,\n),\nThemeData.dark (),\nHome: MainPage (title: 'Special Effects King'),\n)\n: MaterialApp (\nTitle: 'Special Effects King',\nTheme: darkModeModel.darkMode == 1\n?ThemeData.dark\n: ThemeData (\nPrimary Swatch: Colors.blue,\n),\nHome: MainPage (title: 'Special Effects King'),\n);\n},\n),\n)\n```\n\n## Effect\n\nIn this way, we can provide users with the options of automatic follow-up system switching and manual control.\n\n<p class=\"img-tip\" data-str=\"跟随系统开启夜间模式\"><img src=\"https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/7990e8790d894cbd93ce50db2cbd76f0~noop.png\" height=\"754\" width=\"772\"/></p>\n<p class=\"img-tip\" data-str=\"手动开启关闭夜间模式\"><img src=\"https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/3bf8c98403cb46549ddf0032944c2f7f~noop.png\" height=\"676\" width=\"782\"/></p>\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "赵辉",
"full_name": "赵辉",
"email": "zhaohui.im@bytedance.com",
"employee_id": 1000013394,
"lark_id": "6747485868845433100",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/23dbf928-c95a-4e00-937a-a58d39bbc9dg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 1,
"follower_count": 5,
"digg_cnt": 34,
"lark_open_id": "ee1g7e74",
"auth": 0,
"department_name": "互娱研发-平台产品研发-多媒体",
"intro": "",
"roleIds": [],
"score": 88,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 11,
"xid": "14c9c031b6e4bf739588321d23c1a50b",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064983071",
"name": "互娱研发-平台产品研发-多媒体",
"en_name": "RD-IES-Platform-Media"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Hui Zhao",
"leader": {
"id": 1601076,
"name": "姚东伟",
"u_name": "姚东伟 (yaodongwei)",
"email": "yaodongwei@bytedance.com",
"employee_number": 1601076,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 9808871,
"entry_date": 1571011200
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "：[shared_preferences](https://github.com/<em>flutter</em>/plugins/tree/master/packages/shared_preferences#usage...常见的几种状态管理：\n- [InheritedWidget](https://api.<em>flutter</em>.dev/<em>flutter</em>/widgets/InheritedWidget-class.html)\n-"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "Flutter入门基础&进阶",
"author_id": 1000007199,
"comment_count": 0,
"content": "## 入门基础\n\n*   常见动画实现\n\n*   生命周期监测\n\n*   平台通讯实现\n\n*   自定义视图实现\n\n## 进阶\n\n*   Dart的异步编程\n\n  \n\n  \n\n## 常见动画实现\n\n*   一些比较常规的动画，可以使用Transition实现\n\n  \n\n滑动动效示例代码：\n```\nAnimationController _controller = AnimationController(vsync: this,duration: Duration(milliseconds: 300)); //1、定义一个时长300ms 的AnimationController\n//2、定一个一个偏移动画\nAnimatable<Offset> commonSlideTop = Tween<Offset>(\n    begin: const Offset(0.0, -1.0),\n    end: Offset.zero\n).chain(CurveTween(curve: Curves.fastOutSlowIn));//动画变化曲线\n\n@override\nWidget build(BuildContext context) {\n  return SlideTransition(\n      position: _controller.drive(commonSlideTop),//3、应用动画\n      child: Container(...)\n  );\n}\n_controller.forward();//4、开始动画\n```\n用法类似的还有：ScaleTransition，FadeTransition，RotationTransition，PositionedTransition等，可以嵌套使用。\n效果图：\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/056210227b7a4372bcbf5e69804f61ee~tplv-noop.image?width=458&height=354)\n\n  \n\n  \n\n*   多个动画混合可以考虑AnimatedBuilder实现\n\n  \n\n示例代码：\n```\nAnimationController _controller = AnimationController(vsync: this,duration: Duration(milliseconds: 800)); //1、定义一个时长800ms 的AnimationController\n//2、定义多个动画\n_bottomBarWidth = Tween<double>(\n  begin: 0,\n  end: _width,\n).animate(\n  CurvedAnimation(\n    parent: _controller,\n    curve:const Interval(\n      0.0, 1.0,//0-1 表示持续整个动画时长\n      curve:const Cubic(0.39, 0.575, 0.565, 1.0),\n    ),\n  ),\n);\n_bottomBarAlpha = Tween<double>...\n//3、应用动画\nreturn AnimatedBuilder(\n  animation: _controller,\n  builder: (context) => Container(\n    color: Colors.white.withOpacity(_bottomBarAlpha.value),\n    height: 0.5,\n    width: _bottomBarWidth.value,\n  ),\n);\n//4、开始动画\n_controller.repeat();\n```\n效果图：\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/7a87ce84923a46eb84a24345d7c86d4d~tplv-noop.image?width=458&height=352)\n\n  \n\n*   复杂动画可以监听AnimationController实现\n\n  \n\n示例代码：\n```\nAnimationController _controller = AnimationController(vsync: this,duration:const Duration(milliseconds: 300));//1、定义一个时长300ms的AnimationController\n//2、定义动画\nAnimation<double> _factor = Tween<double>(...).animate(...)\n//3、监听动画变化过程\n_factor.addListener((){\n  if(!mounted) return;\n  setState(() {//4、动画变化参数随着改变\n    offset = _factor.value;\n  });\n});\n@override\nWidget build(BuildContext context) {\n  return CustomPaint(//5、应用变化的参数到指定的画笔\n    painter: VolumeEffectPainter(offset,color: widget.color),\n  )；\n}\n```\n  \n\n效果图：\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/f75e578a45704fdbb7d1f2028bea2154~tplv-noop.image?width=458&height=352)\n\n  \n\n*   弹性动画借助SpringSimulation实现\n\n示例代码：\n```\n//1、定义指定时长的AnimationController\nAnimationController _springController = AnimationController(vsync: this ,duration: Duration(milliseconds: 800));\n//2、借助SpringDescription定义三个弹性参数：质量，刚性，阻尼\nconst SpringDescription _spring = SpringDescription(mass: 1.0, stiffness: 300.0, damping: 20.0);\n//3、实例化SpringSimulation\nSpringSimulation _simulation = SpringSimulation(widget._description, 0.0, 1.0, _springController.velocity);\n//4、监听AnimationController，对每个变化过程都使用SpringSimulation作一次变换\n_springController.addListener((){\n  setState(() {\n    _scaleFactor = _simulation.x(_springController.value);\n  });\n});\n```\n\n上述实现一个带弹性的缩放动画，效果：\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/6f7c0d0e05644f71a9ca29b4d8d1716c~tplv-noop.image?width=458&height=352)\n\n  \n\n## 生命周期监测\n\n不同于Native比较完善的生命周期回调，Flutter上实现跟Native一样的生命周期会复杂一点\n\n*   使用WidgetsBindingObserver监听系统生命周期\n\n代码示例：\n```\n//1、继承WidgetsBindingObserver\nclass _MState extends State<...> with WidgetsBindingObserver{\n    @override\n    void initState() {\n        ...\n        WidgetsBinding.instance.addObserver(this);//2、添加observer\n        ...\n    }\n    //3、重写didChangeAppLifecycleState\n    @override\n    void didChangeAppLifecycleState(AppLifecycleState state) {\n         switch (state) {\n          case AppLifecycleState.inactive:break;//App退出前台，随时会被Pause\n          case AppLifecycleState.paused: break;//相当于Activity onPause\n          case AppLifecycleState.resumed:break;//相当于Activity onResume\n          case AppLifecycleState.suspending:break;//App暂时被挂起，一般用不上\n         }\n    }\n}\n```\n使用WidgetsBindingObserver的时候，如果当前的界面被盖住且发生生命周期变化的时候也同样会回调到didChangeAppLifecycleState函数\n  \n\n*   使用RouteAware监听当前界面是否展示\n\n代码示例：\n```\n//1、声明RouteObserver并在App里面注册\nfinal RouteObserver<Route> routeObserver = RouteObserver<Route>();\nreturn MaterialApp(\n  ...\n  navigatorObservers: [\n    ...\n    routeObserver\n  ],\n);\n//2、继承RouteAware\nclass _MState extends State<...> with RouteAware{\n    @override\n    void didChangeDependencies() {\n      super.didChangeDependencies();\n      //3、将监听器注册到routeObserver\n      routeObserver.subscribe(this, ModalRoute.of(context));\n    }\n    //4、重写各个接口作对应处理\n    void didPopNext() {...}//上层界面被弹出，当前界面显示\n    void didPushNext(...) {}//当前界面显示时有新的界面压入，这里会盖住当前界面\n}\n```\n  \n\n结合WidgetsBindingObserver，RouteObserver即可实现拥有生命周期回调的页面\n  \n\n## 平台通讯实现\n\n*   Dart层调用Native方法 —— MethodChannel\n\nJava层代码示例：\n```\n//1、声明MethodChannel标识字符串\nstatic final String VIDEO_UPLOAD_METHOD_CHANNEL = \"tangyuan/video_upload_method\";\n//2、实现MethodChannel接口\npublic class VideoUploadPlugin implements MethodChannel{\n    public static void registerWith(PluginRegistry.Registrar registrar) {\n        VideoUploadPlugin plugin = new VideoUploadPlugin(registrar);\n        //3、在plugin注册的时候注册对应的MethodChannel\n        final MethodChannel channel = new MethodChannel(registrar.messenger(), VIDEO_UPLOAD_METHOD_CHANNEL);\n        channel.setMethodCallHandler(plugin);\n    }\n    @Override\n    public void onMethodCall(MethodCall methodCall, MethodChannel.Result result)    {\n        String method = methodCall.method;//dart调用的方法\n        Object args = methodCall.arguments;//对应方法的参数\n        ...//4、在onMethodCall方法中处理dart层的请求\n        result.success(true);//将对应的结果返回给Dart层\n    }  \n}\n```\nDart层代码示例：\n```\nclass VideoUploadPlugin{\n  //1、实例化MethodChannel，名称与Java层一致\n  static const _methodChannel = MethodChannel('tangyuan/video_upload_method');\n\n  Future<dynamic> callMethodWithParams(String method,Map<dynamic,dynamic> params) async{\n    //2、使用MethodChannel调用Java层方法并接收返回值\n    return await _methodChannel.invokeMethod(method,params);\n  }\n}\n```\n  \n\n*   Native分发事件到Dart —— EventChannel\n\nJava层代码示例：\n```\n//1、声明EventChannel标识字符串\nstatic final String VIDEO_UPLOAD_EVENT_CHANNEL = \"tangyuan/video_upload_event\";\n//2、实现EventChannel.StreamHandler接口\npublic class VideoUploadPlugin implements EventChannel.StreamHandler{\n    EventChannel.EventSink mEventSink;\n    @Override\n    public void onListen(Object o, EventChannel.EventSink eventSink) {\n        mEventSink = eventSink;//Dart层监听该EventChannel时走到\n    }\n    @Override\n    public void onCancel(Object o) {\n        mEventSink = null;//Dart层取消监听该EventChannel时走到\n    }\n    public static void registerWith(PluginRegistry.Registrar registrar) {\n        //3、注册EventChannel\n        new EventChannel(registrar.messenger(), VIDEO_UPLOAD_EVENT_CHANNEL).setStreamHandler(plugin);\n    }\n    //4、向Dart层分发事件\n    if(mEventSink != null) mEventSink.success(result);\n}\n```\n  \n\nDart层代码示例：\n```\nclass VideoUploadPlugin{\n  static VideoUploadPlugin _instance = VideoUploadPlugin._init();\n  static VideoUploadPlugin get instance => _instance;\n  factory VideoUploadPlugin() => _instance;\n  //1、实例化EventChannel\n  static const eventChannel = EventChannel('tangyuan/video_upload_event');\n\n  VideoUploadPlugin._init(){\n    //2、流式监听对应的EventChannel\n    uploadStream = eventChannel.receiveBroadcastStream();\n  }\n  Stream<dynamic> uploadStream;\n  //3、绑定事件处理函数\n  uploadStream.listen(_onUploadCallback);\n}\nvoid _onUploadCallback(event) async {...}//4、处理Native层分发的事件\n```\n  \n\n## 自定义视图实现\n\n自定义视图实现一般使用CustomPaint实现，具体使用示例：\n```\nconst Color _kdefaultColor = const Color(0xFF3D3D3D);\nconst double kArrowBorderHorizontalPadding = 30.0;\nclass ArrowBorder extends StatelessWidget{\n  ArrowBorder({@required this.width,@required this.height,@required this.arrowOffset,this.color = _kdefaultColor});\n  final double width;\n  final double height;\n  final Color color;\n  final double arrowOffset;\n  @override\n  Widget build(BuildContext context) {\n    return SizedBox(\n      width: width,\n      height: height,\n      //1、构建一个CustomPaint，传入自定义的Painter\n      child: CustomPaint(\n        painter: _BorderPainter(arrowOffset,color,1.0,noArrow),\n      ),\n    );\n  }\n}\n//2、实现自定义Painter\nclass _BorderPainter extends CustomPainter{\n  _BorderPainter(this.offset,Color color,double width,this.noArrow){\n    mPaint = Paint();\n    mPaint.isAntiAlias = true;\n    mPaint.color = color;\n    mPaint.style = PaintingStyle.fill;\n    mPaint.strokeWidth = width;\n    mPaint.strokeCap = StrokeCap.round;\n  }\n  Paint mPaint;\n  final double offset;\n  final bool noArrow;\n  @override\n  void paint(Canvas canvas, Size size) {//在paint可以进行任意视图绘制\n    Path path = Path();\n    double horizontalPadding = kArrowBorderHorizontalPadding;\n    path.moveTo(horizontalPadding, 1);\n    path.lineTo(size.width - horizontalPadding, 1);\n    path.lineTo(size.width - horizontalPadding, size.height - 13);\n    path.lineTo(horizontalPadding, size.height - 13);\n    path.lineTo(horizontalPadding, 1);\n    canvas.drawPath(path, mPaint);\n  }\n\n  @override\n  bool shouldRepaint(CustomPainter oldDelegate) {\n    return false;\n  }\n}\n```\n上述代码实现一个带有箭头的蒙层，效果如下：\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/9d9721931ed042fda1314764c6c9c334~tplv-noop.image?width=1200&height=815)\n\n  \n\n  \n\n## Dart的异步编程\n\n  \n\n### 什么是Isolate？\n\n*    Isolate可以简单理解为Dart的线程，跟普通Java线程不同点：\n\n1.  Isolate启动的时候就拥有自己的EventLoop，类比安卓使用了Looper的线程\n\n2.  不同Isolate不共享内存，代码一旦执行无法被打断，所以没有同步锁之类的概念\n\n3.  Isolate之间只能通过Dart提供的API —— Message进行通讯\n\n  \n\n### Isolate调度模型\n\n    每当开启一个Dart线程会自动执行以下操作：\n\n1.  初始化两个队列，名称分别为MicroTask，Event\n\n2.  执行main函数\n\n3.  执行EventLoop\n\n  \n\n   当每个时钟周期到来且当前线程 **没有正在执行的Dart代码** 时，便会执行EventLoop，逻辑伪代码：\n```\nvoid eventLoop(){\n  while (microTaskQueue.isNotEmpty){\n    fetchFirstMicroTaskFromQueue();\n    executeThisMicroTask();\n    return;\n  }\n  if (eventQueue.isNotEmpty){\n    fetchFirstEventFromQueue();\n    executeThisEventRelatedCode();\n  }\n}\n```\n  \n\n其中MicroTask用于执行一些耗时比较短又 **比较高优** 的异步操作，比如说输入框聚焦的时候需要更新输入框的UI并且弹出软键盘，这时候更新输入框就可以使用scheduleMicrotask，可以确保弹出键盘的时候UI已经更新为可输入状态的UI：\n```\nvoid _markNeedsUpdate() {\n  if (_haveScheduledUpdate)\n    return;\n  _haveScheduledUpdate = true;\n  scheduleMicrotask(_update);\n}\n```\n  \n\nEventQueue用于执行一些事件触发后的处理代码：\n\n*   外部事件触发\n\n1.  I/O操作\n\n2.  手势事件\n\n3.  绘制事件\n\n4.  定时器\n\n5.  事件流\n\n     ...\n\n*   Future\n\n  \n\n### 使用示例\n\n*   Future & async & await & Completer\n\n  \n\nFuture示例代码：\n```\nvoid main(){\n    print('Before the Future');\n    Future((){\n        print('Running the Future');\n    }).then((_){\n        print('Future is complete');\n    });\n    print('After the Future');\n}\n```\n上述代码的输出是：\n```\nBefore the Future\nAfter the Future \nRunning the Future \nFuture is complete\n```\nFuture工作流程大致如下：\n\n1.  实例化一个Future并添加到Dart管理的内部数组\n\n2.  Future中需要被执行的代码会直接压入到Event Queue\n\n3.  Future实例会以inComplete状态返回，并线性执行下去\n\n4.  到达指定时机，执行步b骤压入EventQueue的代码\n\n  \n\n*   async 用于修饰方法，配合await关键字使用：\n\n代码示例：\n```\nvoid main() async {\n  ...\n  print('Before await');\n  await Future.delayed(Duration(seconds: 1),(){\n    print('Delay print');\n  });\n  print('After await');\n}\n```\n上述代码输出是：\n```\nBefore await\nDelay print\nAfter await\n```\n  \n\n当对函数增加 async 关键字的时候，Dart默认作以下处理：\n\n1.  函数返回值为Future类型\n\n2.  同步执行代码直到遇到 await 关键字时暂停函数代码执行\n\n3.  await之后的代码将在await 所对应的Future完成之后执行\n\n  \n\n值得注意的是，无论是Future还是async函数里面的代码，并非并行执行。而是塞到EventQueue里面串行执行。如果代码逻辑比较重，比如做一个加密算法，大JSON反序列化 等则会导致主线程阻塞而卡住。\n  \n\n*   Isolate的使用方法\n\n  \n\n我们平时绝大多数的代码都是跑在Dart的主线程 —— Root Isolate。如果遇到一些比较重的逻辑需要并行执行则需要另外创建Isolate，用于执行复杂计算而不卡住主线程\n  \n\n创建Isolate步骤如下：\n1、创建Isolate并连接\n```\nSendPort newIsolateSendPort;//用于给新创建的Isolate发送消息的端口\nIsolate newIsolate;\n\nvoid callerCreateIsolate() async {\n  ReceivePort receivePort = ReceivePort();\n  newIsolate = await Isolate.spawn(\n    callbackFunction,\n    receivePort.sendPort,\n  );\n  //保存用于通讯的端口\n  newIsolateSendPort = await receivePort.first;\n}\n//新创建Isolate的入口\nstatic void callbackFunction(SendPort callerSendPort){\n  //初始化一个用于接受caller信息的接收端口\n  ReceivePort newIsolateReceivePort = ReceivePort();\n\n  //给caller提供当前Isolate端口\n  callerSendPort.send(newIsolateReceivePort.sendPort);\n  ...\n}\n```\n  \n\n2、给Isolate发送信息\n  \n\n```\nFuture<String> sendReceive(String messageToBeSent) async {\n  //用于接收Isolate的回复信息\n  ReceivePort port = ReceivePort();\n  //向Isolate发送信息\n  newIsolateSendPort.send(\n      CrossIsolatesMessage<String>(\n        sender: port.sendPort,\n        message: messageToBeSent,\n      )\n  );\n  //等待Isolate返回信息\n  return port.first;\n}\n\nstatic void callbackFunction(SendPort callerSendPort){\n  ReceivePort newIsolateReceivePort = ReceivePort();\n  callerSendPort.send(newIsolateReceivePort.sendPort);\n  //监听caller发送过来的消息\n  newIsolateReceivePort.listen((dynamic message){\n      CrossIsolatesMessage incomingMessage = message as CrossIsolatesMessage;\n      //处理消息\n      String newMessage = \"complemented string \" + incomingMessage.message;\n      //回复消息给caller\n      incomingMessage.sender.send(newMessage);\n  });\n}\n\n//辅助类\nclass CrossIsolatesMessage<T> {\n  final SendPort sender;\n  final T message;\n  CrossIsolatesMessage({\n    @required this.sender,\n    this.message,\n  });\n}\n```\n  \n\n3、Isolate的销毁\n```\nvoid dispose(){\n  newIsolate?.kill(priority: Isolate.immediate);\n  newIsolate = null;\n}\n```\n  \n\n日常开发中遇到比较复杂的计算可以新开一个Isolate解决卡顿问题。\nFlutter在“src/foundation/isolates.dart”为我们提供compute方法可以快速使用多Isolate处理复杂逻辑：\n```\nList<dynamic> list = data['data'];//解析出一个JSON数组\nList<VideoFeed> _data = await compute(_parseVideoFeeds,list);//使用compute方法异步解析JSON\n//解析函数大致实现如下\nstatic List<VideoFeed> _parseVideoFeeds(List<dynamic> list){\n  List<VideoFeed> result = List();\n  for(dynamic tmp in list){\n    if(tmp is Map && tmp.containsKey('content')){\n      VideoFeed feed = VideoFeed.fromJson(tmp['content']);\n      result.add(feed);\n    }\n  }\n  return result;\n}\n```\n\n## 总结\n\nFlutter是一个比较优秀的跨平台渲染引擎，基本所有原生可以实现的功能，Flutter都可以实现。对于一些性能要求较高的功能比如摄像头采集，视频播放之类的功能，Flutter提供了PlatformView，外接纹理等方式。其本质也是桥接到Native实现。\nDart由于具备AOT，类型安全，无锁GC等特性，性能良好。不过日常的开发中Dart代码都是跑在Dart主线程。遇到一些较重的计算逻辑，可以放到Native实现或者新开一个Isolate处理，避免由于计算逻辑较重导致Dart主线程卡顿。",
"ctime": 1567741152,
"mtime": 1622015774,
"commentable": 0,
"status": 0,
"dig_cnt": 4,
"collect_cnt": 2,
"cover_url": "",
"brief": "",
"article_id": "8702",
"draft_id": "6920191448914755592",
"view_cnt": 3836,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "Flutter Basic & Advanced\n",
"en_content": "## Getting Started\n\n*   Common animation implementation\n\n*   Life cycle monitoring\n\n*   Platform communication implementation\n\n*   Custom view implementation\n\n## Advanced\n\n*   Asynchronous programming for Dart\n\n## Common animation implementation\n\n*   Some more conventional animations can be implemented using Transition\n\nSlide effect sample code:\n\n    AnimationController _controller = AnimationController (vsync: this, duration: Duration (milliseconds: 300 )); // 1. Define an AnimationController with a duration of 300 ms\n    //2, set an offset animation\n    Animatable < Offset > commonSlideTop = Tween < Offset > (\n    Begin: const Offset (0.0, -1.0),\n    End: Offset.zero\n    ).chain (CurveTween (curve: Curves.fastOutSlowIn ));// animation change curve\n\n    @Override\n    Widget build (BuildContext context) {\n    SlideTransition return return (\n    Position: _controller.drive (commonSlideTop ),// 3. Application animation\n    Container (child child)..)\n    );\n    }\n    _controller();// start animation\n\nSimilar usage: ScaleTransition, FadeTransition, Rotation Transition, PositionedTransition, etc., can be nested.\nEffect diagram:\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/056210227b7a4372bcbf5e69804f61ee~tplv-noop.image?width=458\\&height=354)\n\n*   Multiple animation blends can be considered for AnimatedBuilder implementation\n\nSample code:\n\n    AnimationController _controller = AnimationController (vsync: this, duration: Duration (milliseconds: 800 )); // 1. Define an AnimationController with a duration of 800 ms\n    //2, define multiple animations\n    _bottomBarWidth= Tween < double > (\n    To begin: 0,\n    End: _width,\n    ). animate (\n    CurvedAnimation (\n    Parent: _controller,\n    Interval curve: const curve: const (\n    0.0,1.0, //0-1 means the duration of the entire animation\n    Curve: const Cubic (0.39,0.575,0.565,1.0),\n    ),\n    ),\n    );\n    _bottomBarAlpha= Tween < double >...\n    //3, application animation\n    AnimatedBuilder (return return)\n    Animation: _controller,\n    Builder: (context ) => Container (\n    Color: Colors.white.withOpacity(_bottomBarAlpha.value),\n    Height: 0.5,\n    Width: _bottomBarWidth.value,\n    ),\n    );\n    //4, start animation\n    _controller.repeat ();\n\nEffect diagram:\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/7a87ce84923a46eb84a24345d7c86d4d~tplv-noop.image?width=458\\&height=352)\n\n*   Complex animations can listen to AnimationController implementation\n\nSample code:\n\n    AnimationController _controller = AnimationController (vsync: this, duration: const Duration (milliseconds: 300 ));// 1. Define an AnimationController with a duration of 300 ms\n    //2, define animation\n    Animation < double >_factor= Tween < double > (...). animate (...)\n    //3, monitor the animation change process\n    _factor addListener ((){\n    If (! mounted) return;\n    setState (() {// 4. Animation parameters change with changes\n    Offset =_factor.value;\n    });\n    });\n    @Override\n    Widget build (BuildContext context) {\n    Return CustomPaint (//5, apply the changed parameters to the specified brush\n    Painter: VolumeEffectPainter (offset, color: widget.color),\n    );\n    }\n\nEffect diagram:\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/f75e578a45704fdbb7d1f2028bea2154~tplv-noop.image?width=458\\&height=352)\n\n*   Flexible Animation with Spring Simulation\n\nSample code:\n\n    //1. Define an AnimationController for a specified duration\n    AnimationController _springController = AnimationController (vsync: this, duration: Duration (milliseconds: 800));\n    //2. Define three elastic parameters with SpringDescription: mass, rigidity, and damping\n    const SpringDescription _spring = SpringDescription (mass: 1.0, stiffness: 300.0, damping: 20.0);\n    //3, instantiation SpringSimulation\n    SpringSimulation _simulation = SpringSimulation (widget._description, 0.0, 1.0, _springController.velocity);\n    //4, monitor the Animation Controller, and use Spring Simulation to make a transformation for each change process\n    _springController addListener ((){\n    setState (() {\n    _scaleFactor=_simulation.x(_springController.value);\n    });\n    });\n\nThe above implementation of a zoom animation with elasticity, the effect:\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/6f7c0d0e05644f71a9ca29b4d8d1716c~tplv-noop.image?width=458\\&height=352)\n\n## Life cycle monitoring\n\nUnlike Native's more refined lifecycle callbacks, implementing the same lifecycle as Native on Flutter is a bit more complicated\n\n*   Use WidgetsBindingObserver to monitor the system lifecycle\n\nCode example:\n\n    //1, inheriting WidgetsBindingObserver\n    Class _MState extends State <...> with WidgetsBindingObserver {\n    @Override\n    Void initState () {\n    ...\n    WidgetsBinding.instance.addObserver (this );// 2. Add observer\n    ...\n    }\n    //3, rewrite didChangeAppLifecycleState\n    @Override\n    void didChangeAppLifecycleState (AppLifecycleState state) {\n    Switch (state) {\n    Case AppLifecycleState.inactive: break; //App exit the foreground and will be Pause at any time\n    Case AppLifecycleState.paused: break; // equivalent to Activity onPause\n    Case AppLifecycleState.resumed: break; // equivalent to Activity onResume\n    Case AppLifecycleState.suspending: break; //App temporarily suspended, generally not used\n    }\n    }\n    }\n\nWhen using WidgetsBindingObserver, if the current interface is covered and the life cycle changes, it will also be called back to the didChangeAppLifecycleState function\n\n*   Use RouteAware to monitor whether the current interface is displayed\n\nCode example:\n\n    //1, declare RouteObserver and register in the App\n    Final RouteObserver < Route > routeObserver = RouteObserver < Route >();\n    MaterialApp return return (\n    ...\n    NavigatorObservers: [\n    ...\n    routeObserver\n    ],\n    );\n    //2, inherit RouteAware\n    Class _MState extends State <...> with RouteAware {\n    @Override\n    void didChangeDependencies () {\n    Super.didChangeDependencies ();\n    //3. Register listeners with routeObserver\n    routeObserver.subscribe (this, ModalRoute.of (context));\n    }\n    //4, rewrite each interface for corresponding processing\n    void didPopNext () {...} // the upper interface is popped up, and the current interface is displayed\n    didPushNext (void void...) {} // new interface is pressed when the current interface is displayed, this will cover the current interface\n    }\n\nCombined with WidgetsBindingObserver, RouteObserver enables pages with lifecycle callbacks\n\n## Platform communication implementation\n\n*   Dart layer calls Native method —— MethodChannel\n\nJava layer code example:\n\n    //1, declare MethodChannel identity character string\n    static final String VIDEO_UPLOAD_METHOD_CHANNEL =  \"tangyuan/video_upload_method\";\n    //2, implement MethodChannel interface\n    public class VideoUploadPlugin implements MethodChannel{\n    Public static void registerWith (PluginRegistry. Registrar registrar) {\n    VideoUploadPlugin plugin = new VideoUploadPlugin (registrar);\n    //3. Register the corresponding MethodChannel when registering in the plugin\n    final MethodChannel channel = new MethodChannel (registrar. messenger (), VIDEO_UPLOAD_METHOD_CHANNEL);\n    Channel.setMethodCallHandler (plugin);\n    }\n    @Override\n    Public void onMethodCall (MethodCall methodCall, MethodChannel.Result result ) {\n    String method =methodCall.method method called;// dart\n    Object args = methodCall.arguments; // the parameters of the corresponding method\n    .../ / 4. Handle requests from the dart layer in the onMethodCall method\n    Result.success (true );// returns the corresponding result to the Dart layer\n    }\n    }\n\nDart layer code example:\n\n    VideoUploadPlugin {class class\n    //1, instantiate MethodChannel, name consistent with Java layer\n    static const _methodChannel = MethodChannel (' tangyuan/video_upload_method ');\n\n    Future < dynamic > callMethodWithParams (String method, Map < dynamic, dynamic > params) async {\n    //2, use MethodChannel to call Java layer methods and receive return values\n    return await _methodChannel.invokeMethod (method, params);\n    }\n    }\n\n*   Native distributes events to Dart —— EventChannel\n\nJava layer code example:\n\n    //1 Declare EventChannel identity character string\n    static final String VIDEO_UPLOAD_EVENT_CHANNEL =  \"tangyuan/video_upload_event\";\n    //2, implement EventChannel.StreamHandler interface\n    public class VideoUploadPlugin implements EventChannel.StreamHandler{\n    EventChannel. EventSink mEventSink;\n    @Override\n    Public void onListen (Object o, EventChannel.EventSink eventSink ) {\n    mEventSink = eventSink; //Dart layer listens to the EventChannel\n    }\n    @Override\n    Public void onCancel (Object o) {\n    mEventSink = null; //Dart layer unlistens when the EventChannel goes\n    }\n    Public static void registerWith (PluginRegistry. Registrar registrar) {\n    //3, Register EventChannel\n    New EventChannel (registrar.messenger (), VIDEO_UPLOAD_EVENT_CHANNEL).setStreamHandler (plugin);\n    }\n    //4 Distribute events to the Dart layer\n    If (mEventSink != null) mEventSink.success (result);\n    }\n\nDart layer code example:\n\n    VideoUploadPlugin {class class\n    static VideoUploadPlugin _instance = VideoUploadPlugin._init ();\n    Static VideoUploadPlugin get instance => _ instance;\n    Factory VideoUploadPlugin () => _ instance;\n    //1, instantiating EventChannel\n    static const eventChannel = EventChannel (' tangyuan/video_upload_event ');\n\n    VideoUploadPlugin. _init () {\n    //2, streaming monitor corresponding EventChannel\n    uploadStream = eventChannel.receiveBroadcastStream ();\n    }\n    Stream < dynamic > uploadStream;\n    //3, binding event handlers\n    uploadStream.listen (_onUploadCallback);\n    }\n    Void _onUploadCallback (event) async {...} //4 and handle events distributed by the Native layer\n\n## Custom view implementation\n\nCustom view implementation generally uses CustomPaint implementation, specific examples:\n\n    const Color _kdefaultColor = const Color (0xFF3D3D3D);\n    const double kArrowBorderHorizontalPadding = 30.0;\n    class ArrowBorder extends StatelessWidget{\n    ArrowBorder ({@requiredthis.width, @required this.height, @requirementthis.arrowOffset, this.color = _ kdefaultColor});\n    The final double width;\n    The final double height;\n    Color final final color;\n    The final double arrowOffset;\n    @Override\n    Widget build (BuildContext context) {\n    SizedBox return return\n    Width: width,\n    Height: height,\n    //1, build a CustomPaint, pass in a custom Painter\n    CustomPaint (child child)\n    Painter: _BorderPainter (arrowOffset, color, 1.0, noArrow),\n    ),\n    );\n    }\n    }\n    //2, implement custom Painter\n    class _BorderPainter extends CustomPainter{\n    _BorderPainter(this.offset, Color color, double width, this.noArrow) {\n    mPaint = Paint ();\n    mPaint.isAntiAlias = true;\n    mPaint.color= color;\n    mPaint.style=PaintingStyle.fill;\n    mPaint.strokeWidth = width;\n    mPaint.strokeCap =StrokeCap.round;\n    }\n    Paint mPaint;\n    The final double offset;\n    The final bool noArrow;\n    @Override\n    Void paint (Canvas canvas, Size size ) {// can be drawn in any view in paint\n    Path path = Path ();\n    double horizontalPadding = kArrowBorderHorizontalPadding;\n    Path.moveTo (horizontalPadding, 1);\n    path.lineTo(size.width - horizontalPadding, 1);\n    path.lineTo(size.width - Horizontal Padding, size.height - 13);\n    Path.lineTo (horizontalPadding, size.height - 13);\n    Path.lineTo (horizontalPadding, 1);\n    canvas.drawPath (path, mPaint);\n    }\n\n    @Override\n    Bool shouldRepaint (CustomPainter oldDelegate) {\n    To return false;\n    }\n    }\n\nThe above code implements a mask layer with arrows, and the effect is as follows:\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/9d9721931ed042fda1314764c6c9c334~tplv-noop.image?width=1200\\&height=815)\n\n## Asynchronous programming for Dart\n\n### What is Isolate?\n\n*   Isolate can be simply understood as a thread of Dart, which is different from ordinary Java threads:\n\n1.  Isolate has its own EventLoop when it starts, similar to Android using Looper's thread\n\n2.  Unlike Isolate, which does not share memory, code cannot be interrupted once executed, so there is no concept of synchronization lock\n\n3.  Isolate can only communicate through API —— Message provided by Dart\n\n### Isolate scheduling model\n\nEach time a Dart thread is started, the following actions are automatically performed:\n\n1.  Initialize two queues named MicroTask, Event\n\n2.  Execute main function\n\n3.  Execute EventLoop\n\nWhen each clock cycle comes and the current thread**No Dart code running**When, EventLoop will be executed, and the logical pseudo code:\n\n    void eventLoop(){\n      while (microTaskQueue.isNotEmpty){\n        fetchFirstMicroTaskFromQueue();\n        executeThisMicroTask();\n        return;\n      }\n      if (eventQueue.isNotEmpty){\n        fetchFirstEventFromQueue();\n        executeThisEventRelatedCode();\n      }\n    }\n\nWhich MicroTask is used to perform some time-consuming and**Compare high**For example, when the input box is focused, the UI of the input box needs to be updated and the soft keyboard pops up. At this time, the input box can be updated using scheduleMicrotask, which can ensure that the UI has been updated to the UI of the input state when the keyboard pops up:\n\n    void _markNeedsUpdate() {\n      if (_haveScheduledUpdate)\n        return;\n      _haveScheduledUpdate = true;\n      scheduleMicrotask(_update);\n    }\n\nEventQueue is used to execute the processing code after some events are triggered:\n\n*   External event triggering\n\n1.  I/O operation\n\n2.  Gesture event\n\n3.  Draw events\n\n4.  Timer\n\n5.  Event flow\n\n     ...\n\n*   Future\n\n### Use example\n\n*   Future & async & await & Completer\n\nFuture sample code:\n\n    void main(){\n        print('Before the Future');\n        Future((){\n            print('Running the Future');\n        }).then((_){\n            print('Future is complete');\n        });\n        print('After the Future');\n    }\n\nThe output of the above code is:\n\n    Before the Future\n    After the Future \n    Running the Future \n    Future is complete\n\nFuture workflows are broadly as follows:\n\n1.  Instantiate a Future and add it to an internal array managed by Dart\n\n2.  Future code that needs to be executed is pushed directly into Event Queue\n\n3.  Future instances will return inComplete and execute linearly\n\n4.  When the specified time is reached, execute the code of step b to press into EventQueue\n\n*   Async is used to modify the method and is used with the await keyword:\n\nCode example:\n\n    void main() async {\n      ...\n      print('Before await');\n      await Future.delayed(Duration(seconds: 1),(){\n        print('Delay print');\n      });\n      print('After await');\n    }\n\nThe above code output is:\n\n    Before await\n    Delay print\n    After await\n\nWhen adding the async keyword to the function, Dart defaults to the following:\n\n1.  The function returns a value of type Future\n\n2.  Synchronize code execution until function code execution is paused when the await keyword is encountered\n\n3.  The code after await will be executed after the future corresponding to await is completed\n\nIt is worth noting that the code in the Future or async functions is not executed in parallel. Instead, it is inserted into the EventQueue to execute serially. If the code logic is heavy, such as making an encryption algorithm, large JSON deserialization, etc., it will cause the main thread to block and get stuck.\n\n*   How to use Isolate\n\nMost of our code usually runs on Dart's main thread —— Root Isolate. If you encounter some heavy logic that needs to be executed in parallel, you need to create another Isolate to perform complex calculations without blocking the main thread\n\nCreate Isolate as follows:\n1\\. Create Isolate and connect\n\n    SendPort newIsolateSendPort; // port for sending messages to newly created Isolate\n    Isolate newIsolate;\n\n    void callerCreateIsolate () async {\n    ReceivePort receivePort = ReceivePort ();\n    NewIsolate = await Isolate.spawn (\n    CallbackFunction,\n    Port receive. sendPort,\n    );\n    // save ports for communication\n    newIsolateSendPort = await receivePort.first;\n    }\n    // newly created Isolate portal\n    Static void callbackFunction (SendPort callerSendPort) {\n    // initialize a receiving port for receiving caller messages\n    ReceivePort newIsolateReceivePort = ReceivePort ();\n\n    // provide caller with current Isolate port\n    callerSendPort.send (newIsolateReceivePort.sendPort);\n    ...\n    }\n\nSend Information to Isolate\n\n    Future < String > sendReceive (String messageToBeSent) async {\n    // used to receive Isolate reply messages\n    ReceivePort port = ReceivePort ();\n    // send a message to Isolate\n    newIsolateSendPort.send (\n    CrossIsolatesMessage < String > (\n    Sender: sendPort,\n    Message: message ToBeS ent,\n    )\n    );\n    // wait for Isolate to return information\n    Return port.first;\n    }\n\n    Static void callbackFunction (SendPort callerSendPort) {\n    ReceivePort newIsolateReceivePort = ReceivePort ();\n    callerSendPort.send (newIsolateReceivePort.sendPort);\n    // listening for messages from the caller\n    newIsolateReceivePort.listen ((dynamic message) {\n    CrossIsolatesMessage incomingMessage = message as CrossIsolatesMessage;\n    // process messages\n    String newMessage = \" complemented string \" + incomingMessage.message;\n    // reply message to caller\n    incomingMessage.sender.send (newMessage);\n    });\n    }\n\n    // auxiliary\n    CrossIsolatesMessage class class < T > {\n    SendPort final final sender;\n    T final final message;\n    CrossIsolatesMessage ({\n    @Required this.sender,\n    In this message,\n    });\n    }\n\nIsolate destruction\n\n    void dispose(){\n      newIsolate?.kill(priority: Isolate.immediate);\n      newIsolate = null;\n    }\n\nIf you encounter more complicated calculations in daily development, you can open a new Isolate to solve the Caton problem.\nFlutter gives us a compute method in src/foundation/isolates.dart to quickly handle complex logic using multi-Isolate:\n\n    List < dynamic > list = data ['data '];// parses out a JSON array\n    List < VideoFeed >_data= await compute (_parseVideoFeeds, list );// parses JSON asynchronously using the compute method\n    // analytic function is roughly implemented as follows\n    Static List < VideoFeed >_parseVideoFeeds (List < dynamic > list) {\n    List < VideoFeed > result = List ();\n    For (dynamic tmp in list) {\n    If (tmp is Map && tmp.containsKey ('content ')){\n    VideoFeed feed = VideoFeed.fromJson (tmp ['content ']);\n    result.add (feed);\n    }\n    }\n    To return result;\n    }\n\n## Summary\n\nFlutter is an excellent cross-platform rendering engine. Flutter can implement basically all the functions that can be realized by native users. For some high-performance functions such as camera capture and video playback, Flutter provides PlatformView, external texture, etc. Its essence is also to bridge to Native implementation.\nDart has good performance due to AOT, type safety, lock-free GC and other characteristics. However, in daily development, Dart code runs on the Dart main thread. If you encounter some heavy calculation logic, you can put it into the Native implementation or open a new Isolate process to avoid the Dart main thread jamming due to heavy calculation logic.\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "朱伟鹤",
"full_name": "朱伟鹤",
"email": "zhuweihe@bytedance.com",
"employee_id": 1000007199,
"lark_id": "6563800808960295182",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/793dddc1-973b-445a-ae43-bdb22363363g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 4,
"lark_open_id": "af71bcd6",
"auth": 0,
"department_name": "产品研发和工程架构部-Client Infrastructure-Test Infra",
"intro": "",
"roleIds": [],
"score": 2,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 1,
"xid": "ea62df45b9760219e2fb8ec2c278d3a3",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064988205",
"name": "产品研发和工程架构部-Client Infrastructure-Test Infra",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Test Infra"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Weihe Zhu",
"leader": {
"id": 6370652,
"name": "Simon Zhang",
"u_name": "Simon Zhang (simonzhang)",
"email": "simonzhang@bytedance.com",
"employee_number": 6370652,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 9772212,
"entry_date": 1528243200
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 570,
"name": "Isolate",
"follow_count": 0,
"item_count": 1,
"en_name": "Isolate",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "是一个比较优秀的跨平台渲染引擎，基本所有原生可以实现的功能，<em>Flutter</em>都可以实现。...对于一些性能要求较高的功能比如摄像头采集，视频播放之类的功能，<em>Flutter</em>提供了PlatformView，外接纹理等方式。其本质也是桥接到Native实现。"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"video_info": {
"id_type": 24,
"item_id": "6844026093268107278",
"create_id": 1000004678,
"title": "首届Flutter技术沙龙-Flutter包体积优化",
"description": "移动跨平台技术Flutter的深耕与探讨，题材丰富，来自西瓜视频、好好学习、移动平台部的5位讲师，深度讲解Flutter技术，带你领略下一代跨平台技术的魅力。",
"url": "v03313680000bln76r6e89pcfur2seu0",
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1yG_2x8zDZ6Qz5Hx6HHldVg4eeHP4Eshs/view?usp=sharing"
},
"cover": "https://p9-tt.bytecdn.cn/origin/tos-cn-i-0000/1923e337968f4d10b904793c3c9e84e6",
"status": 0,
"digg_cnt": 2,
"view_cnt": 35,
"collect_cnt": 96,
"comment_cnt": 0,
"point_score": 0,
"ctime": 1567519916,
"mtime": 1621759725,
"tag": 100,
"video_status": 1,
"set_id": "0",
"content_mtime": 1567519916,
"duration": 1020,
"original": 0
},
"author": {
"name": "王丛林",
"full_name": "王丛林",
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"lark_id": "6628001948719120644",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 3,
"follower_count": 76,
"digg_cnt": 311,
"lark_open_id": "6cd9ee19",
"auth": 0,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "一块儿橡皮玩一天～",
"roleIds": [],
"score": 1162,
"status": 1,
"answer_digg_cnt": 5,
"question_cnt": 5,
"answer_cnt": 3,
"is_follow": false,
"collect_cnt": 213,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Conglin Wang",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 8506729,
"entry_date": 1543190400
},
"owners": [
{
"name": "李梦云",
"full_name": "李梦云",
"email": "limengyun@bytedance.com",
"employee_id": 1000007314,
"lark_id": "6442603982660567309",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/2e0e00000135969f32bda~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 1,
"follower_count": 2,
"digg_cnt": 26,
"lark_open_id": "12fc299f",
"auth": 0,
"department_name": "产品研发和工程架构部-Client Infrastructure-App Health",
"intro": "",
"roleIds": [],
"score": 76,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 15,
"xid": "ea0c6ad91afa1c84eae72f5adf3ce732",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064990939",
"name": "产品研发和工程架构部-Client Infrastructure-App Health",
"en_name": "Product RD and Infrastructure-Client Infrastructure-App Health"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Mengyun Li",
"leader": {
"id": 9771926,
"name": "孙念",
"u_name": "孙念 (sunnian)",
"email": "sunnian@bytedance.com",
"employee_number": 9771926,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 7037382,
"entry_date": 1497398400
}
],
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 1026,
"name": "基础技术",
"follow_count": 36,
"item_count": 38,
"en_name": "Basic tech",
"icon": "",
"is_follow": false
},
{
"id": 1715,
"name": "首届Flutter技术沙龙",
"follow_count": 1,
"item_count": 5,
"en_name": "The first Flutter tech salon",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"highlight": {
"content": "移动跨平台技术<em>Flutter</em>的深耕与探讨，题材丰富，来自西瓜视频、好好学习、移动平台部的5位讲师，深度讲解<em>Flutter</em>技术，带你领略下一代跨平台技术的魅力。"
},
"item_set_info": {
"id": 14,
"item_id": "6897931266113732622",
"id_type": 39,
"title": "首届Flutter技术沙龙 系列分享",
"brief": "首届Flutter技术沙龙 系列分享",
"collect_cnt": 0,
"status": 0,
"ctime": 1606050205,
"mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606050184615_362ddf9c81b6bbfb6275df912e205867.png",
"tag": 1,
"item_list": [
{
"item_id": "6844026091242258440",
"id_type": 24
},
{
"item_id": "6844026093268107278",
"id_type": 24
},
{
"item_id": "6844026092777373703",
"id_type": 24
},
{
"item_id": "6844026091636523022",
"id_type": 24
},
{
"item_id": "6844026092211159054",
"id_type": 24
}
],
"content_mtime": 1622714447
},
"is_digg": false,
"is_collect": false,
"id_type": 24
},
{
"video_info": {
"id_type": 24,
"item_id": "6844026092777373703",
"create_id": 1000004678,
"title": "首届Flutter技术沙龙-Flutter状态管理方案",
"description": "移动跨平台技术Flutter的深耕与探讨，题材丰富，来自西瓜视频、好好学习、移动平台部的5位讲师，深度讲解Flutter技术，带你领略下一代跨平台技术的魅力。",
"url": "v02313480000bln6uc8nrm1sr06vc89g",
"doc": {
"name": "view?usp=sharing",
"url": "https://drive.google.com/file/d/1h_FD2Cviiu0czvs7fL8RpPZTsW2Oizld/view?usp=sharing"
},
"cover": "https://p9-tt.bytecdn.cn/origin/tos-cn-i-0000/1923e337968f4d10b904793c3c9e84e6",
"status": 0,
"digg_cnt": 2,
"view_cnt": 53,
"collect_cnt": 98,
"comment_cnt": 1,
"point_score": 0,
"ctime": 1567519916,
"mtime": 1621760283,
"tag": 100,
"video_status": 1,
"set_id": "0",
"content_mtime": 1567519916,
"duration": 1647,
"original": 0
},
"author": {
"name": "王丛林",
"full_name": "王丛林",
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"lark_id": "6628001948719120644",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 3,
"follower_count": 76,
"digg_cnt": 311,
"lark_open_id": "6cd9ee19",
"auth": 0,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "一块儿橡皮玩一天～",
"roleIds": [],
"score": 1162,
"status": 1,
"answer_digg_cnt": 5,
"question_cnt": 5,
"answer_cnt": 3,
"is_follow": false,
"collect_cnt": 213,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Conglin Wang",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 8506729,
"entry_date": 1543190400
},
"owners": [
{
"name": "林帅斌",
"full_name": "林帅斌",
"email": "linshuaibin@bytedance.com",
"employee_id": 1000003640,
"lark_id": "6648773688122409224",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/0670b54c-6d9c-4edd-9fe4-b027304a3f2g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 1,
"lark_open_id": "d4686288",
"auth": 0,
"department_name": "产品研发和工程架构部-Client Infrastructure-App Framework Android",
"intro": "",
"roleIds": [],
"score": 2,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 5,
"xid": "fa01c2e36de0960a63955b50b9696c35",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064984016",
"name": "产品研发和工程架构部-Client Infrastructure-App Framework Android",
"en_name": "Product RD and Infrastructure-Client Infrastructure-App Framework Android"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Shuaibin Lin",
"leader": {
"id": 8621588,
"name": "张添富",
"u_name": "张添富 (zhangtianfu)",
"email": "zhangtianfu@bytedance.com",
"employee_number": 8621588,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 5585108,
"entry_date": 1548028800
}
],
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 1026,
"name": "基础技术",
"follow_count": 36,
"item_count": 38,
"en_name": "Basic tech",
"icon": "",
"is_follow": false
},
{
"id": 1715,
"name": "首届Flutter技术沙龙",
"follow_count": 1,
"item_count": 5,
"en_name": "The first Flutter tech salon",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"highlight": {
"content": "移动跨平台技术<em>Flutter</em>的深耕与探讨，题材丰富，来自西瓜视频、好好学习、移动平台部的5位讲师，深度讲解<em>Flutter</em>技术，带你领略下一代跨平台技术的魅力。"
},
"item_set_info": {
"id": 14,
"item_id": "6897931266113732622",
"id_type": 39,
"title": "首届Flutter技术沙龙 系列分享",
"brief": "首届Flutter技术沙龙 系列分享",
"collect_cnt": 0,
"status": 0,
"ctime": 1606050205,
"mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606050184615_362ddf9c81b6bbfb6275df912e205867.png",
"tag": 1,
"item_list": [
{
"item_id": "6844026091242258440",
"id_type": 24
},
{
"item_id": "6844026093268107278",
"id_type": 24
},
{
"item_id": "6844026092777373703",
"id_type": 24
},
{
"item_id": "6844026091636523022",
"id_type": 24
},
{
"item_id": "6844026092211159054",
"id_type": 24
}
],
"content_mtime": 1622714447
},
"is_digg": false,
"is_collect": false,
"id_type": 24
},
{
"video_info": {
"id_type": 24,
"item_id": "6844026123374821383",
"create_id": 1000004678,
"title": "Flutter-工程实战",
"description": "Flutter专题课程将为大家提供完整的Flutter学习路线，从入门到实战，快速掌握Flutter核心开发技能。",
"url": "v02313dc0000bnu9mka7u0rau7jbb6j0",
"doc": {
"name": "edit?usp=sharing",
"url": "https://docs.google.com/presentation/d/1Ckxx-PIUntqjlEz09ESdLfqATU4zH0EMtTOynDStGwk/edit?usp=sharing"
},
"cover": "https://tech-proxy.bytedance.net/tos/images/1598495669701_81eb3ec813f7858ccf6ba137d08c70d0.png",
"status": 0,
"digg_cnt": 6,
"view_cnt": 506,
"collect_cnt": 366,
"comment_cnt": 5,
"point_score": 0,
"ctime": 1574756006,
"mtime": 1621760783,
"tag": 100,
"video_status": 1,
"set_id": "0",
"content_mtime": 1574756006,
"duration": 3523,
"original": 0
},
"author": {
"name": "王丛林",
"full_name": "王丛林",
"email": "wangconglin@bytedance.com",
"employee_id": 1000004678,
"lark_id": "6628001948719120644",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/241ee0011d3f109203ecb~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 3,
"follower_count": 76,
"digg_cnt": 311,
"lark_open_id": "6cd9ee19",
"auth": 0,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "一块儿橡皮玩一天～",
"roleIds": [],
"score": 1162,
"status": 1,
"answer_digg_cnt": 5,
"question_cnt": 5,
"answer_cnt": 3,
"is_follow": false,
"collect_cnt": 213,
"xid": "cb8466dd89e9dc3f1b61c761797a5b63",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Conglin Wang",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 8506729,
"entry_date": 1543190400
},
"owners": [
{
"name": "林一一",
"full_name": "林一一",
"email": "linyiyi@bytedance.com",
"employee_id": 1000008720,
"lark_id": "6703323720120795395",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da5c000b07852577b06a~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 1,
"digg_cnt": 3,
"lark_open_id": "7a2e426d",
"auth": 0,
"department_name": "产品研发和工程架构部-Client Infrastructure-Browser Kernel and Cross Platform-Lynx",
"intro": "",
"roleIds": [],
"score": 128,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 8,
"xid": "fa4c5dabd1f892b7567313d1c578efe3",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000065000863",
"name": "产品研发和工程架构部-Client Infrastructure-Browser Kernel and Cross Platform-Lynx",
"en_name": "Product RD and Infrastructure-Client Infrastructure-Browser Kernel and Cross Platform-Lynx"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Yiyi Lin",
"leader": {
"id": 3850189,
"name": "刘守群",
"u_name": "刘守群 (liushouqun)",
"email": "liushouqun@bytedance.com",
"employee_number": 3850189,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 9232738,
"entry_date": 1560729600
}
],
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 1713,
"name": "大前端",
"follow_count": 3,
"item_count": 10,
"en_name": "Grand frontend",
"icon": "",
"is_follow": false
},
{
"id": 1724,
"name": "Flutter专题课程",
"follow_count": 8,
"item_count": 7,
"en_name": "Flutter special course",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"highlight": {
"content": "<em>Flutter</em>专题课程将为大家提供完整的<em>Flutter</em>学习路线，从入门到实战，快速掌握<em>Flutter</em>核心开发技能。"
},
"item_set_info": {
"id": 19,
"item_id": "6897936454698483725",
"id_type": 39,
"title": "Flutter 专题课程",
"brief": "Flutter 专题课程",
"collect_cnt": 4,
"status": 0,
"ctime": 1606051037,
"mtime": 1622714447,
"cover": "https://tech-proxy.bytedance.net/tos/images/1606051004079_81eb3ec813f7858ccf6ba137d08c70d0.png",
"tag": 1,
"item_list": [
{
"item_id": "6844026122951196680",
"id_type": 24
},
{
"item_id": "6844026125459390478",
"id_type": 24
},
{
"item_id": "6844026124440174606",
"id_type": 24
},
{
"item_id": "6844026123374821383",
"id_type": 24
},
{
"item_id": "6844026126080147463",
"id_type": 24
},
{
"item_id": "6844026124943491086",
"id_type": 24
},
{
"item_id": "6844026123941068807",
"id_type": 24
}
],
"content_mtime": 1622714447
},
"is_digg": false,
"is_collect": false,
"id_type": 24
},
{
"article_info": {
"title": "Flutter嵌套问题",
"author_id": 1000125452,
"comment_count": 0,
"content": "作为初学者，在代码层面上如何解决Dart嵌套问题？\t\t\t\t\t\n\n",
"ctime": 1583921553,
"mtime": 1619490252,
"commentable": 0,
"status": 0,
"dig_cnt": 0,
"collect_cnt": 2,
"cover_url": "",
"brief": "",
"article_id": "6802890903309516814",
"draft_id": "0",
"view_cnt": 107,
"point_score": 0,
"answer_count": 3,
"id_type": 22,
"parent_id": "0",
"en_title": "",
"en_content": "",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "刘敏",
"full_name": "刘敏",
"email": "liumin.superman@bytedance.com",
"employee_id": 1000125452,
"lark_id": "6794957511343472642",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/cd03b3dd-9463-40ac-b23c-0bacfa6b498g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 9,
"follower_count": 51,
"digg_cnt": 1316,
"lark_open_id": "6a4cgeaa",
"auth": 2,
"department_name": "产品研发和工程架构部-技术学院-内容国际化中台",
"intro": "",
"roleIds": [
2
],
"score": 2748,
"status": 1,
"answer_digg_cnt": 41,
"question_cnt": 40,
"answer_cnt": 24,
"is_follow": false,
"collect_cnt": 283,
"xid": "4e66839044d38b843d6346dfc472e8ca",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991092",
"name": "产品研发和工程架构部-技术学院-内容国际化中台",
"en_name": "Product RD and Infrastructure-Tech Academy-Content Internationalization"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Min Liu",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 1102261,
"entry_date": 1582070400
},
"category": {
"id": 2,
"name": "前端",
"en_name": "FE",
"brief": "在Mobile、Desktop、PC等场景下，开发Web应用产品并保障研发的工程质量与性能体验。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606449989,
"show_type": 3,
"is_show": 1,
"en_brief": "Develop web application products and ensure the quality and performance experience of R&D projects under scenarios such as Mobile, Desktop, PC, etc.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 922,
"name": "嵌套方案",
"follow_count": 0,
"item_count": 1,
"en_name": "Nested plan",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "作为初学者，在代码层面上如何解决Dart嵌套问题？"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 22,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "Flutter状态管理方案\t",
"author_id": 1000125452,
"comment_count": 0,
"content": "作为一个初学者，在状态管理方案上怎么选择？大家有好的建议嘛？\t\t\t\t",
"ctime": 1583921397,
"mtime": 1620719815,
"commentable": 0,
"status": 0,
"dig_cnt": 0,
"collect_cnt": 1,
"cover_url": "",
"brief": "",
"article_id": "6802890114918776845",
"draft_id": "0",
"view_cnt": 61,
"point_score": 0,
"answer_count": 2,
"id_type": 22,
"parent_id": "0",
"en_title": "",
"en_content": "",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "刘敏",
"full_name": "刘敏",
"email": "liumin.superman@bytedance.com",
"employee_id": 1000125452,
"lark_id": "6794957511343472642",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/cd03b3dd-9463-40ac-b23c-0bacfa6b498g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 9,
"follower_count": 51,
"digg_cnt": 1316,
"lark_open_id": "6a4cgeaa",
"auth": 2,
"department_name": "产品研发和工程架构部-技术学院-内容国际化中台",
"intro": "",
"roleIds": [
2
],
"score": 2748,
"status": 1,
"answer_digg_cnt": 41,
"question_cnt": 40,
"answer_cnt": 24,
"is_follow": false,
"collect_cnt": 283,
"xid": "4e66839044d38b843d6346dfc472e8ca",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991092",
"name": "产品研发和工程架构部-技术学院-内容国际化中台",
"en_name": "Product RD and Infrastructure-Tech Academy-Content Internationalization"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Min Liu",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 1102261,
"entry_date": 1582070400
},
"category": {
"id": 2,
"name": "前端",
"en_name": "FE",
"brief": "在Mobile、Desktop、PC等场景下，开发Web应用产品并保障研发的工程质量与性能体验。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606449989,
"show_type": 3,
"is_show": 1,
"en_brief": "Develop web application products and ensure the quality and performance experience of R&D projects under scenarios such as Mobile, Desktop, PC, etc.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
},
{
"id": 463,
"name": "状态管理",
"follow_count": 0,
"item_count": 3,
"en_name": "State management",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "作为一个初学者，在状态管理方案上怎么选择？大家有好的建议嘛？"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 22,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "Flutter 路由源码解析",
"author_id": 1000008976,
"comment_count": 0,
"content": "\n## 前言\n\n这是博客[《Flutter路由 - Navigator 》](https://bytekm.bytedance.net/kmf/articleDetail/2974)的番外篇，如果你没有看过主篇真的不建议你直接看这篇文章，因为它真的炒鸡炒鸡枯燥乏味……\n\n不讲客套话啦，我们分别从`Navigator `的`push`和`pop`两个方法去探索源码以及一些重要的细节。\n\n## push\n当我们想要push一个Page在界面上时，我们可以调用如下代码：\n\n```\nNavigator.push(\n  context,\n  PageRouteBuilder(pageBuilder: (context, animation, secondaryAnimation) {\n    return MyPage(args);\n  }));\n```\n\n我们以`Navigator.push(BuildContext context, Route<T> route)`方法为起始进行追述：\n\n```\nstatic Future<T> push<T extends Object>(BuildContext context, Route<T> route) {\n    return Navigator.of(context).push(route);\n}\n```\n\n### 1.`NavigatorState `对象检索\n\n就像上篇文章有提到过的，`Navigator.push`是一个静态方法，使得你可以在任何地方进行调用，其内部通过`of`方法在`Element `树（`BuildContext `是 `Element `的抽象类）中进行向上搜索。我们看下`Navigator.of`方法：\n\n```\nstatic NavigatorState of(\n    BuildContext context, {\n      bool rootNavigator = false,\n      bool nullOk = false,\n    }) {\n    final NavigatorState navigator = rootNavigator\n        ? context.rootAncestorStateOfType(const TypeMatcher<NavigatorState>())\n        : context.ancestorStateOfType(const TypeMatcher<NavigatorState>());\n    return navigator;\n}\n```\n\n主要通过`rootNavigator `变量判断是否要检索根部Navigator，`rootAncestorStateOfType`向上查找最根部匹配类型对象，`ancestorStateOfType`向上查找最近的匹配类型对象。从这个方法我们也可以知道`Navigator.of`方法查找的不是`Navigator`而是`NavigatorState `,这个也比较容易理解，`Navigator`是一个`StatefulWidget`,具体的逻辑都在它的State对象当中。\n\n### 2.push实现\n\n接下来看`NavigatorState.push `实现：\n\n```\n//0\nfinal List<Route<dynamic>> _history = <Route<dynamic>>[];\n\nFuture<T> push<T extends Object>(Route<T> route) {\n   \t...\n   \t //1\n    final Route<dynamic> oldRoute = _history.isNotEmpty ? _history.last : null;\n    //2\n    route._navigator = this;\n    //3\n    route.install(_currentOverlayEntry);\n    //4\n    _history.add(route);\n    //5\n    route.didPush();\n    route.didChangeNext(null);\n    if (oldRoute != null) {\n      oldRoute.didChangeNext(route);\n      route.didChangePrevious(oldRoute);\n    }\n    //6\n    for (NavigatorObserver observer in widget.observers)\n      observer.didPush(route, oldRoute);\n    _afterNavigation();\n    return route.popped;\n}\n```\n\n- 0.`_history `就是`Navigator `所维护的界面栈，但它只是一个普通的`List`。\n\n- 1. 获取原本在栈顶的route，因为`_history `是一个普通的`List `，所以栈顶就是最后一个元素。\n\n- 2.让新加入的`route`和`Navigator `引用绑定。\n\n- 3.`install` 是 `route`转换为`OverlayEntry`，并插入到`List<OverlayEntry>`中的重要过程，`_currentOverlayEntry `是`oldRoute `对应的`OverlayEntry `,传入`_currentOverlayEntry `的意思是插入到它的上面。具体细节我们稍后细讲。\n\n- 4.`route`入栈。\n\n- 5.完成新老界面的转换，内部有一些事件和动画处理。\n\n- 6.通知所有的`Navigator `观察者。\n\n### 3. route.install\n\n我们最关心的是第3步，`route.install(_currentOverlayEntry);` `Route`类里这个方法是一个空实现，具体细节在它的子类中，我们重点看`OverlayRoute`的实现：\n\n```\nabstract class OverlayRoute<T> extends Route<T> {\n...\n  @override\n  List<OverlayEntry> get overlayEntries => _overlayEntries;\n  final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n  \n  @override\n  void install(OverlayEntry insertionPoint) {\n    _overlayEntries.addAll(createOverlayEntries());\n    navigator.overlay?.insertAll(_overlayEntries, above: insertionPoint);\n    super.install(insertionPoint);\n  }\n...\n```\n\n一个`Route`的`_overlayEntries` 通常包含两个`OverlayEntry `，一个是遮罩，一个是界面本身，都在`createOverlayEntries `中创建。\n\n先对`_overlayEntries`完成两个`OverlayEntry `的`add`,然后调用`navigator`所持有的`overlay`对象，将遮罩和界面插入到`overlay`所持有的`List<OverlayEntry>`中，以备绘制到界面之上。\n\n\n### 4. createOverlayEntries\n\n这是`Route `到`OverlayEntry `的关键,具体的实现在`ModalRoute `中：\n\n```\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() sync* {\n    yield _modalBarrier = OverlayEntry(builder: _buildModalBarrier);\n    yield OverlayEntry(builder: _buildModalScope, maintainState: maintainState);\n  }\n  ...\n\n```\n\n对`yield `语法不熟悉没关系，你只要知道这个方法最终会返回两个`OverlayEntry `对象就好了。`_modalBarrier `就是遮罩层，就是Dialog那个背景遮罩。\n\n我们重点关心第二个page的创建。`OverlayEntry `中传入两个参数：\n\n- builder：这是一个function, 我们自定义的Page创建就在这个方法之中。\n\n- maintainState: 这个属性我们在上篇博客有讲，表示当这个 Widget 不可见时，是否需要继续保持它的状态，是否需要让它继续活着。通常一个 Page `maintainState `为true， Dialog 为 false。\n\n\n### 5. _buildModalScope\n\n看下`_buildModalScope `实现:\n\n```\nWidget _buildModalScope(BuildContext context) {\n    return _modalScopeCache ??= _ModalScope<T>(\n      key: _scopeKey,\n      route: this,\n      // _ModalScope calls buildTransitions() and buildChild(), defined above\n    );\n}\n```\n\n`_buildModalScope `创建了一个 Widget `_ModalScope `，并将`Route`自己传了进去。`_ModalScope `是个啥呢？\n\n`_ModalScope ` 是一个`StatefulWidget `,我们直接看它的 `State`的`build`方法：\n\n```\n@override\n  Widget build(BuildContext context) {\n    return _ModalScopeStatus(\n      route: widget.route,\n      isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n      canPop: widget.route.canPop, // _routeSetState is called if this updates\n      child: Offstage(\n        offstage: widget.route.offstage, // _routeSetState is called if this updates\n        child: PageStorage(\n          bucket: widget.route._storageBucket, // immutable\n          child: FocusScope(\n            node: widget.route.focusScopeNode, // immutable\n            child: RepaintBoundary(\n              child: AnimatedBuilder(\n                animation: _listenable, // immutable\n                builder: (BuildContext context, Widget child) {\n                  return widget.route.buildTransitions(\n                    context,\n                    widget.route.animation,\n                    widget.route.secondaryAnimation,\n                    IgnorePointer(\n                      ignoring: widget.route.animation?.status == AnimationStatus.reverse,\n                      child: child,\n                    ),\n                  );\n                },\n                child: _page ??= RepaintBoundary(\n                  key: widget.route._subtreeKey, // immutable\n                  child: Builder(   // ======！！！重点关注这个代码！！！！！！\n                    builder: (BuildContext context) {\n                      return widget.route.buildPage(\n                        context,\n                        widget.route.animation,\n                        widget.route.secondaryAnimation,\n                      );\n    ...\n```\n\n可以看到`_ModalScope `内部又嵌套了很多`Widget`，并且创建所用的数据都来自`Route`，我们重点关注最后一个`Builder `,可以看到它最后`return` 调用的是 `route`的`buildPage`方法，眼熟吗？就是我们最开始调用`push`方法传入的自定义`PageRouteBuilder `对象：\n\n```\nNavigator.push(\n  context,\n  PageRouteBuilder(pageBuilder: (context, animation, secondaryAnimation) {\n    return MyPage(args);\n  }));\n```\n\n到这里你知道你的传入的 Route 是如何被使用的了。\n\n我们回头看一下`Route`转化为`OverlayEntry `之后，`Overlay`是如何处理的：\n\n### 6. 插入到Overlay中\n\n之前我们是这样插入到`overlay `中的:`navigator.overlay?.insertAll(_overlayEntries, above: insertionPoint);` `navigator.overlay`实际是`OverlayState `\n\n\n```\nclass OverlayState extends State<Overlay> with TickerProviderStateMixin {\n...\nvoid insertAll(Iterable<OverlayEntry> entries, { OverlayEntry above }) {\n    ...\n    //1\n    for (OverlayEntry entry in entries) {\n      entry._overlay = this;\n    }\n    //2\n    setState(() {\n      final int index = above == null ? _entries.length : _entries.indexOf(above) + 1;\n      _entries.insertAll(index, entries);\n    });\n  }\n...\n```\n\n- 1. 将每一个要插入到集合中的`OverlayEntry`绑定自身，绑定自身的原因是我们上篇文章所讲的：**元素自治**。 插入是由`Overlay`中进行的，但删除却是每个元素自己调用的。\n\n- 2. 看到了熟悉的`setState((){}`方法，集合插入完成后，将触发`Overlay`的 rebuild。\n\n所以接下来我们看一下 `OverlayState` 的 `build`方法：\n\n```\n@override\n  Widget build(BuildContext context) {\n    //1\n    final List<Widget> onstageChildren = <Widget>[];\n    final List<Widget> offstageChildren = <Widget>[];\n    bool onstage = true;\n    //2\n    for (int i = _entries.length - 1; i >= 0; i -= 1) {\n      final OverlayEntry entry = _entries[i];\n      //3\n      if (onstage) {\n        //4\n        onstageChildren.add(_OverlayEntry(entry));\n        if (entry.opaque)\n          onstage = false;\n       //5\n      } else if (entry.maintainState) {\n        offstageChildren.add(TickerMode(enabled: false, child: _OverlayEntry(entry)));\n      }\n    }\n    //6\n    return _Theatre(\n    \t//7\n      onstage: Stack(\n        fit: StackFit.expand,\n        children: onstageChildren.reversed.toList(growable: false),\n      ),\n      //8\n      offstage: offstageChildren,\n    );\n  }\n```\n\n\n- 1.创建两个空列表，分别存储“台上”将要被绘制的，和“台下”不需要绘制的 Widget。\n\n- 2.开始遍历所有的OverlayEntry，准备将他们分配到两个集合当中。值得注意的是，这里是倒序遍历，后加入的元素绘制到最上层。\n\n- 3.最开始每个`OverlayEntry `都是有机会被绘制的，直到某个`OverlayEntry `的`opaque=true`，其他`OverlayEntry `没有机会“上台“了\n\n- 4.可以看到`OverlayEntry `被当做参数传给了`_OverlayEntry `,完成了一个纯 Dart 类到 Widget 的转换。`_OverlayEntry `代码很简单，它将根据`OverlayEntry中的属性`进行 build。\n\n- 5.没有机会上台的`OverlayEntry `开始判断`maintainState`值，需要保存的状态的进入`offstageChildren `,不需要的保存状态的，没有机会参与这一次的 build ，他们将被销毁。\n\n- 6.分配结束之后，进入剧场： `_Theatre `。\n\n- 7.台上需要被绘制的进入`Stack `组件，准备绘制。\n\n- 8.不需要被绘制的，只会进行build。\n\n至此，新push的Page完成了创建和绘制。\n\n\n## pop\n\n看完了 push , 我们在看一下 pop：\n\n### 1.pop\n\n```\nbool pop<T extends Object>([ T result ]) {\n\t...\n\t//1\n    final Route<dynamic> route = _history.last;\n    bool debugPredictedWouldPop;\n    //2\n    if (route.didPop(result ?? route.currentResult)) {\n      if (_history.length > 1) {\n       //3\n        _history.removeLast();\n        if (route._navigator != null)\n          _poppedRoutes.add(route);\n         //4\n        _history.last.didPopNext(route);\n        //5\n        for (NavigatorObserver observer in widget.observers)\n          observer.didPop(route, _history.last);\n      } else {\n        return false;\n      }\n    } else {\n\t\t...\n    }\n    _afterNavigation();\n    return true;\n  }\n```\n\n- 1.获取集合末尾，也就是栈顶的`route`，它将被pop。\n\n- 2.可以看到`didPop`是有返回值的，也就说如果返回了 false，是可以不弹出的。如果返回了 true，`didPop`内部有一些销毁处理，我们稍后看。\n\n- 3.如果`didPop`返回了 true, 会做出栈处理。\n\n- 4.通知下一个route 你回到前台了。\n\n- 5.通知所有的观察者。\n\n\n### 2.didPop\n\n我们重点关注 Page 回收的处理，所以看一下`OverlayRoute`中的 `didPop`：\n\n```\nabstract class OverlayRoute<T> extends Route<T> {\n...\n  @override\n  bool didPop(T result) {\n    final bool returnValue = super.didPop(result);\n    if (finishedWhenPopped)\n      navigator.finalizeRoute(this);\n    return returnValue;\n  }\n```\n\n看一下`navigator.finalizeRoute`\n\n```\nvoid finalizeRoute(Route<dynamic> route) {\n    ...\n    route.dispose();\n  }\n```\n↓\n\n```\nabstract class OverlayRoute<T> extends Route<T> {\n...\n@override\n  void dispose() {\n    for (OverlayEntry entry in _overlayEntries)\n      entry.remove();\n    _overlayEntries.clear();\n    super.dispose();\n}\n```\n\n可以看到遍历执行了所有`OverlayEntry `的`remove`方法：\n\n```\nvoid remove() {\n\t//1\n    final OverlayState overlay = _overlay;\n    _overlay = null;\n    //2\n    if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n      SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n        //3\n        overlay._remove(this);\n      });\n    } else {\n      overlay._remove(this);\n    }\n  }\n```\n\n- 1.清楚引用，避免内存泄露\n\n- 2.判断一下当前调度机状态，稍后或立刻执行`OverlayState `的`_remove`方法.\n\n```\nvoid _remove(OverlayEntry entry) {\n    if (mounted) {\n      _entries.remove(entry);\n      setState(() { /* entry was removed */ });\n    }\n  }\n```\n\n从集合中清楚当前的`OverlayEntry `,并触发一次 `Overlay ` 的rebuild，因为`_entries`已经没有当前界面了，rebuild之后也就自然不会存在了。\n\n\n## 结语\n\n好啦，push和pop的代码流程都过完啦~ \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
"ctime": 1552290651,
"mtime": 1622701940,
"commentable": 0,
"status": 0,
"dig_cnt": 4,
"collect_cnt": 1,
"cover_url": "",
"brief": "",
"article_id": "2973",
"draft_id": "6920191433064333325",
"view_cnt": 1966,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "Flutter routing source code analysis\n",
"en_content": "## Preface\n\nThis is a blog[Flutter Routing - Navigator](https://bytekm.bytedance.net/kmf/articleDetail/2974)If you haven't read the main article, it is really not recommended that you read this article directly, because it is really boring to stir-fry chicken......\n\nNo more pleasantries, let's start` Navigator  `Of`push`And`pop`Two ways to explore the source code and some important details.\n\n## push\n\nWhen we want to push a page on the interface, we can call the following code:\n\n    Navigator.push(\n      context,\n      PageRouteBuilder(pageBuilder: (context, animation, secondaryAnimation) {\n        return MyPage(args);\n      }));\n\nWe take`Navigator.push(BuildContext context, Route<T> route)`The method is to trace the beginning:\n\n    static Future<T> push<T extends Object>(BuildContext context, Route<T> route) {\n        return Navigator.of(context).push(route);\n    }\n\n### 1.` NavigatorState  `Object retrieval\n\nAs mentioned in the previous article,`Navigator.push`Is a static method that allows you to call it from anywhere, and its internal`of`Method in` Element  `Tree (` BuildContext  `Yes` Element  `In the abstract class). Let's look at`Navigator.of`Method:\n\n    static NavigatorState of(\n        BuildContext context, {\n          bool rootNavigator = false,\n          bool nullOk = false,\n        }) {\n        final NavigatorState navigator = rootNavigator\n            ? context.rootAncestorStateOfType(const TypeMatcher<NavigatorState>())\n            : context.ancestorStateOfType(const TypeMatcher<NavigatorState>());\n        return navigator;\n    }\n\nMainly through` rootNavigator  `The variable determines whether to retrieve the root Navigator,`rootAncestorStateOfType`Find the most root matching type object up,`ancestorStateOfType`Look up the nearest matching type object. From this method we can also know`Navigator.of`Method search is not`Navigator`But` NavigatorState  `, This is also easier to understand,`Navigator`Is a`StatefulWidget`, The specific logic is in its State object.\n\n### 2. Push implementation\n\nNext look` NavigatorState.push  `Achieve:\n\n    //0\n    final List<Route<dynamic>> _history = <Route<dynamic>>[];\n\n    Future<T> push<T extends Object>(Route<T> route) {\n       \t...\n       \t //1\n        final Route<dynamic> oldRoute = _history.isNotEmpty ? _history.last : null;\n        //2\n        route._navigator = this;\n        //3\n        route.install(_currentOverlayEntry);\n        //4\n        _history.add(route);\n        //5\n        route.didPush();\n        route.didChangeNext(null);\n        if (oldRoute != null) {\n          oldRoute.didChangeNext(route);\n          route.didChangePrevious(oldRoute);\n        }\n        //6\n        for (NavigatorObserver observer in widget.observers)\n          observer.didPush(route, oldRoute);\n        _afterNavigation();\n        return route.popped;\n    }\n\n*   0.` _history  `Is` Navigator  `The interface stack is maintained, but it is just a common`List`。\n\n*   1.  Get the route that was originally at the top of the stack because` _history  `Is an ordinary` List  `, so the top of the stack is the last element.\n\n*   2\\. Let newly joined`route`And` Navigator  `Reference binding.\n\n*   3.`install`Yes`route`Convert to`OverlayEntry`, and insert into`List<OverlayEntry>`Important process in,` _currentOverlayEntry  `Yes` oldRoute  `Corresponding` OverlayEntry  `, Afferent` _currentOverlayEntry  `It means to insert it on top. We will talk about the specific details later.\n\n*   4.`route`Into the stack.\n\n*   5\\. Complete the conversion of the new and old interfaces, with some events and animation processing inside.\n\n*   6\\. Notify all` Navigator  `Observer.\n\n### 3. route.install\n\nOur main concern is step 3,`route.install(_currentOverlayEntry);` `Route`This method in the class is an empty implementation. The specific details are in its subclasses, and we focus on`OverlayRoute`Realization of:\n\n    abstract class OverlayRoute<T> extends Route<T> {\n    ...\n      @override\n      List<OverlayEntry> get overlayEntries => _overlayEntries;\n      final List<OverlayEntry> _overlayEntries = <OverlayEntry>[];\n      \n      @override\n      void install(OverlayEntry insertionPoint) {\n        _overlayEntries.addAll(createOverlayEntries());\n        navigator.overlay?.insertAll(_overlayEntries, above: insertionPoint);\n        super.install(insertionPoint);\n      }\n    ...\n\nOne`Route`Of`_overlayEntries`Usually contains two` OverlayEntry  `, one is the mask, one is the interface itself, all in` createOverlayEntries  `Created in.\n\nRight first`_overlayEntries`Complete two` OverlayEntry  `Of`add`, Then call`navigator`Holding`overlay`Object, insert the mask and interface into`overlay`Holding`List<OverlayEntry>`In order to prepare for drawing on the interface.\n\n### 4. createOverlayEntries\n\nThis is` Route  `To` OverlayEntry  `The key, concrete implementation in` ModalRoute  `In:\n\n```\nabstract class ModalRoute<T> extends TransitionRoute<T> with LocalHistoryRoute<T> {\n...\n\n  @override\n  Iterable<OverlayEntry> createOverlayEntries() sync* {\n    yield _modalBarrier = OverlayEntry(builder: _buildModalBarrier);\n    yield OverlayEntry(builder: _buildModalScope, maintainState: maintainState);\n  }\n  ...\n\n```\n\nRight` yield  `It doesn't matter if the syntax is not familiar, you just need to know that this method will eventually return two` OverlayEntry  `The object is fine.` _modalBarrier  `This is the mask layer, which is the background mask of Dialog.\n\nWe focus on the creation of the second page.` OverlayEntry  `Two parameters are passed in:\n\n*   Builder: This is a function, our custom page creation in this method.\n\n*   MaintainState: This attribute we talked about in the previous blog, indicating whether it is necessary to keep the widget in its state when it is not visible, and whether it is necessary to keep it alive. Usually a Page` maintainState  `Is true, Dialog is false.\n\n### 5. \\_buildModalScope\n\nTake a look` _buildModalScope  `Achieve:\n\n    Widget _buildModalScope(BuildContext context) {\n        return _modalScopeCache ??= _ModalScope<T>(\n          key: _scopeKey,\n          route: this,\n          // _ModalScope calls buildTransitions() and buildChild(), defined above\n        );\n    }\n\n` _buildModalScope  `Created a widget` _ModalScope  `, and will`Route`He passed it in.` _ModalScope  `What is it?\n\n` _ModalScope  `Is a` StatefulWidget  `, we look at it directly`State`Of`build`Method:\n\n    @Override\n    Widget build (BuildContext context) {\n    Return _ModalScopeStatus (\n    Route: widget.route,\n    isCurrent: widget.route.isCurrent, // _routeSetState is called if this updates\n    canPop: widget.route.canPop, // _routeSetState is called if this updates\n    Offstage child child (\n    Offstage: widget.route.offstage, // _routeSetState is called if this updates\n    PageStorage (child child)\n    Bucket: widget.route._storageBucket , // immutable\n    FocusScope (child child)\n    Node: widget.route.focusScopeNode , // immutable\n    RepaintBoundary (child child)\n    Child: AnimatedBuilder (\n    Animation: _listenable, // immutable\n    Builder: (BuildContext context, Widget child) {\n    Return widget.route.buildTransitions (\n    In context,\n    widget.route.animation,\n    widget.route.secondaryAnimation,\n    IgnorePointer (\n    Ignoring: widget.route.animation?.status == AnimationStatus.reverse,\n    A child,\n    ),\n    );\n    },\n    Child: _page?? = RepaintBoundary (\n    Key: widget.route._subtreeKey , // immutable\n    Child: Builder (//====!!!Focus on this code!!!!!!\n    Builder: (BuildContext context) {\n    Return widget.route.buildPage (\n    In context,\n    widget.route.animation,\n    widget.route.secondaryAnimation,\n    );\n    ...\n\nCan see` _ModalScope  `A lot more nested inside`Widget`, and the data used to create is from`Route`, we focus on the last` Builder  `, You can see it finally`return`Called is`route`Of`buildPage`The method, does it look familiar? Is that when we first called`push`Customization of method incoming` PageRouteBuilder  `Object:\n\n    Navigator.push(\n      context,\n      PageRouteBuilder(pageBuilder: (context, animation, secondaryAnimation) {\n        return MyPage(args);\n      }));\n\nHere you know how your incoming Route is used.\n\nLet's look back`Route`Into` OverlayEntry  `After that,`Overlay`How to deal with:\n\n### 6. Insert into Overlay\n\nThis is how we inserted` overlay  `In:`navigator.overlay?.insertAll(_overlayEntries, above: insertionPoint);` `navigator.overlay`Actually` OverlayState  `\n\n    class OverlayState extends State<Overlay> with TickerProviderStateMixin {\n    ...\n    void insertAll(Iterable<OverlayEntry> entries, { OverlayEntry above }) {\n        ...\n        //1\n        for (OverlayEntry entry in entries) {\n          entry._overlay = this;\n        }\n        //2\n        setState(() {\n          final int index = above == null ? _entries.length : _entries.indexOf(above) + 1;\n          _entries.insertAll(index, entries);\n        });\n      }\n    ...\n\n*   1.  Insert each of the`OverlayEntry`The reason for binding itself is what we said in the previous article:**Element autonomy**. Insertion is made by`Overlay`But the deletion is called by each element itself.\n\n*   2.  Saw the familiar`setState((){}`Method, after the collection insertion is completed, will trigger`Overlay`To rebuild.\n\nSo let's take a look`OverlayState`Of`build`Method:\n\n    @override\n      Widget build(BuildContext context) {\n        //1\n        final List<Widget> onstageChildren = <Widget>[];\n        final List<Widget> offstageChildren = <Widget>[];\n        bool onstage = true;\n        //2\n        for (int i = _entries.length - 1; i >= 0; i -= 1) {\n          final OverlayEntry entry = _entries[i];\n          //3\n          if (onstage) {\n            //4\n            onstageChildren.add(_OverlayEntry(entry));\n            if (entry.opaque)\n              onstage = false;\n           //5\n          } else if (entry.maintainState) {\n            offstageChildren.add(TickerMode(enabled: false, child: _OverlayEntry(entry)));\n          }\n        }\n        //6\n        return _Theatre(\n        \t//7\n          onstage: Stack(\n            fit: StackFit.expand,\n            children: onstageChildren.reversed.toList(growable: false),\n          ),\n          //8\n          offstage: offstageChildren,\n        );\n      }\n\n*   1\\. Create two empty lists to store widgets that will be drawn \"on stage\" and \"off stage\" that do not need to be drawn.\n\n*   2\\. Start traversing all OverlayEntries and prepare to distribute them into two collections. It is worth noting that this is a reverse traversal, and the added elements are drawn to the top layer.\n\n*   3\\. Start each` OverlayEntry  `Have a chance to be drawn until some` OverlayEntry  `Of`opaque=true`, Other` OverlayEntry  `No chance to \"go on stage.\"\n\n*   4\\. It can be seen` OverlayEntry  `Passed as parameters` _OverlayEntry  `, Completed a pure Dart class to Widget conversion.` _OverlayEntry  `The code is simple, it will be based on`OverlayEntry中的属性`To build.\n\n*   5\\. No chance to go on stage` OverlayEntry  `Start judging`maintainState`Value, the entry of the state to be saved` offstageChildren  `, Unwanted preservation status, no chance to participate in this build, they will be destroyed.\n\n*   6\\. After the assignment, enter the theater:` _Theatre  `。\n\n*   7\\. Entry that needs to be drawn on the stage` Stack  `Component, ready to draw.\n\n*   8\\. What does not need to be drawn will only be built.\n\nSo far, the newly pushed Page has been created and drawn.\n\n## pop\n\nAfter watching the push, let's take a look at the pop:\n\n### 1.pop\n\n    bool pop<T extends Object>([ T result ]) {\n    \t...\n    \t//1\n        final Route<dynamic> route = _history.last;\n        bool debugPredictedWouldPop;\n        //2\n        if (route.didPop(result ?? route.currentResult)) {\n          if (_history.length > 1) {\n           //3\n            _history.removeLast();\n            if (route._navigator != null)\n              _poppedRoutes.add(route);\n             //4\n            _history.last.didPopNext(route);\n            //5\n            for (NavigatorObserver observer in widget.observers)\n              observer.didPop(route, _history.last);\n          } else {\n            return false;\n          }\n        } else {\n    \t\t...\n        }\n        _afterNavigation();\n        return true;\n      }\n\n*   1\\. Get the end of the collection, that is, the top of the stack`route`, It will be pop.\n\n*   2\\. It can be seen`didPop`There is a return value, which means that if false is returned, it can not pop up. If true is returned,`didPop`There is some destruction inside, we will see later.\n\n*   3\\. If`didPop`Returns true, will do stack processing.\n\n*   Notify the next route that you are back to the front desk.\n\n*   5\\. Notify all observers.\n\n### 2.didPop\n\nWe focus on page recycling, so take a look`OverlayRoute`In`didPop`：\n\n    abstract class OverlayRoute<T> extends Route<T> {\n    ...\n      @override\n      bool didPop(T result) {\n        final bool returnValue = super.didPop(result);\n        if (finishedWhenPopped)\n          navigator.finalizeRoute(this);\n        return returnValue;\n      }\n\nTake a look`navigator.finalizeRoute`\n\n    void finalizeRoute(Route<dynamic> route) {\n        ...\n        route.dispose();\n      }\n\n↓\n\n    abstract class OverlayRoute<T> extends Route<T> {\n    ...\n    @override\n      void dispose() {\n        for (OverlayEntry entry in _overlayEntries)\n          entry.remove();\n        _overlayEntries.clear();\n        super.dispose();\n    }\n\nYou can see that the traversal executed all` OverlayEntry  `Of`remove`Method:\n\n    void remove() {\n    \t//1\n        final OverlayState overlay = _overlay;\n        _overlay = null;\n        //2\n        if (SchedulerBinding.instance.schedulerPhase == SchedulerPhase.persistentCallbacks) {\n          SchedulerBinding.instance.addPostFrameCallback((Duration duration) {\n            //3\n            overlay._remove(this);\n          });\n        } else {\n          overlay._remove(this);\n        }\n      }\n\n*   1\\. Clear reference to avoid memory leaks\n\n*   2\\. Determine the current dispatcher status and execute it later or immediately` OverlayState  `Of`_remove`Method.\n\n<!---->\n\n    void _remove(OverlayEntry entry) {\n        if (mounted) {\n          _entries.remove(entry);\n          setState(() { /* entry was removed */ });\n        }\n      }\n\nClear the current from the collection` OverlayEntry  `, and trigger once` Overlay  `To rebuild because`_entries`There is no current interface, and it will naturally not exist after rebuild.\n\n## Conclusion\n\nOkay, the code flow for push and pop is over ~\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "李兆轩",
"full_name": "李兆轩",
"email": "zhaoxuan.li@bytedance.com",
"employee_id": 1000008976,
"lark_id": "6611285200196337927",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/bbcb4c41-3454-4127-8899-dd7e73e1a42g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 11,
"digg_cnt": 107,
"lark_open_id": "8efd7597",
"auth": 0,
"department_name": "TikTok 研发-用户增长-客户端",
"intro": "",
"roleIds": [],
"score": 55,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 19,
"xid": "8b5350011ddafeb1361af53b2fad9832",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064992368",
"name": "TikTok 研发-用户增长-客户端",
"en_name": "TikTok Eng-Growth-Mobile"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Zhaoxuan Li",
"leader": {
"id": 5181199,
"name": "杜鹏",
"u_name": "杜鹏 (cooper.du)",
"email": "cooper.du@bytedance.com",
"employee_number": 5181199,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 5910293,
"entry_date": 1539302400
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
},
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "## 前言\n\n这是博客[《<em>Flutter</em>路由 - Navigator 》](https://bytekm.bytedance.net/kmf/articleDetail/2974)的番外篇，如果你没有看过主篇真的不建议你直接看这篇文章"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "Flutter 缺点是啥？为啥阿里新业务弃用 Flutter？",
"author_id": 1000123965,
"comment_count": 0,
"content": "都说 <span data-word-id=\"1384\" class=\"abbreviate-word\"><span data-word-id=\"1384\" class=\"abbreviate-word\"><span data-word-id=\"1384\" class=\"abbreviate-word\">Flutter</span></span></span> 性能接近原生，上手程度也相对友好，跨端，生态不知道咋样，反正近年来听到的都是优点，想了解一下使用过的同学吐槽一下",
"ctime": 1618317782,
"mtime": 1622095979,
"commentable": 0,
"status": 0,
"dig_cnt": 0,
"collect_cnt": 0,
"cover_url": "",
"brief": "",
"article_id": "6950621229044727839",
"draft_id": "0",
"view_cnt": 50,
"point_score": 0,
"answer_count": 1,
"id_type": 22,
"parent_id": "0",
"en_title": "",
"en_content": "",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "文瑞锋",
"full_name": "文瑞锋",
"email": "wenruifeng@bytedance.com",
"employee_id": 1000123965,
"lark_id": "6791612716411781121",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/e8469dab-0f92-4188-b4c5-dd72901f9d4g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 1,
"digg_cnt": 117,
"lark_open_id": "8ed512fd",
"auth": 0,
"department_name": "产品研发和工程架构部-幸福里-前端",
"intro": "",
"roleIds": [],
"score": 285,
"status": 1,
"answer_digg_cnt": 110,
"question_cnt": 5,
"answer_cnt": 77,
"is_follow": false,
"collect_cnt": 0,
"xid": "a36ef90fa977405bade1286319761502",
"participate_time": 0,
"badge": {
"Activity": 1,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064981428",
"name": "产品研发和工程架构部-幸福里-前端",
"en_name": "Product RD and Infrastructure-FRealEstate-FE"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Ruifeng Wen",
"leader": {
"id": 2515695,
"name": "杜文",
"u_name": "杜文 (duwen.x)",
"email": "duwen.x@bytedance.com",
"employee_number": 2515695,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 3577620,
"entry_date": 1581292800
},
"category": {
"id": 2,
"name": "前端",
"en_name": "FE",
"brief": "在Mobile、Desktop、PC等场景下，开发Web应用产品并保障研发的工程质量与性能体验。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606449989,
"show_type": 3,
"is_show": 1,
"en_brief": "Develop web application products and ensure the quality and performance experience of R&D projects under scenarios such as Mobile, Desktop, PC, etc.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
},
{
"id": 2821,
"name": "技术吐槽",
"follow_count": 0,
"item_count": 7,
"en_name": "Tech Roast",
"icon": "",
"is_follow": false
},
{
"id": 2857,
"name": "每日一问",
"follow_count": 41,
"item_count": 165,
"en_name": "Daily question",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "<span data-word-id=\"1384\" class=\"abbreviate-word\"><span data-word-id=\"1384\" class=\"abbreviate-word\"><em>Flutter</em>"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 22,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"video_info": {
"id_type": 24,
"item_id": "6862623897733316622",
"create_id": 1000007875,
"title": "Flutter 实战入门",
"description": "Flutter 实战入门",
"url": "v02313e10000bsuf39j5d3unphetcqpg",
"doc": {
"name": "",
"url": "https://bytedance.feishu.cn/docs/doccns2WOGobka39l8XBohnOx4c"
},
"cover": "",
"status": 0,
"digg_cnt": 1,
"view_cnt": 8,
"collect_cnt": 14,
"comment_cnt": 0,
"point_score": 50,
"ctime": 1597829594,
"mtime": 1621760346,
"tag": 0,
"video_status": 1,
"set_id": "0",
"content_mtime": 1597829594,
"duration": 1916,
"original": 0
},
"author": {
"name": "施佳乐",
"full_name": "施佳乐",
"email": "alice.shi@bytedance.com",
"employee_id": 1000007875,
"lark_id": "6605346756303520013",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/699db2c7-5515-4833-a56a-85ad1d2390dg~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 24,
"follower_count": 47,
"digg_cnt": 130,
"lark_open_id": "14g6edd5",
"auth": 0,
"department_name": "互娱研发-前端-音乐",
"intro": "",
"roleIds": [],
"score": 3899,
"status": 1,
"answer_digg_cnt": 1,
"question_cnt": 0,
"answer_cnt": 1,
"is_follow": false,
"collect_cnt": 144,
"xid": "7b97928aace085fd3055246c578ccd23",
"participate_time": 0,
"badge": {
"Activity": 1,
"ArticleAndVideo": 0,
"PointOfView": 2
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064987411",
"name": "互娱研发-前端-音乐",
"en_name": "IES-FE-Music"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Jiale Yi",
"leader": {
"id": 7177105,
"name": "陆爱松",
"u_name": "陆爱松 (luaisong)",
"email": "luaisong@bytedance.com",
"employee_number": 7177105,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 9525970,
"entry_date": 1537920000
},
"owners": [
{
"name": "王旭",
"full_name": "王旭",
"email": "wangxu.3@bytedance.com",
"employee_id": 1000080929,
"lark_id": "6766408841266479374",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/d40abc73-7626-4b28-835e-2df22cd0f51g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 9,
"follower_count": 10,
"digg_cnt": 29,
"lark_open_id": "bced2d3a",
"auth": 0,
"department_name": "互娱研发-前端-音乐",
"intro": "",
"roleIds": [],
"score": 240,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 40,
"xid": "edfec8b3bc34ed1e860d2e7aba947ba7",
"participate_time": 0,
"badge": {
"Activity": 1,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064987411",
"name": "互娱研发-前端-音乐",
"en_name": "IES-FE-Music"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Xu Wang",
"leader": {
"id": 7177105,
"name": "陆爱松",
"u_name": "陆爱松 (luaisong)",
"email": "luaisong@bytedance.com",
"employee_number": 7177105,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 8106116,
"entry_date": 1575417600
}
],
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"category": {
"id": 2,
"name": "前端",
"en_name": "FE",
"brief": "在Mobile、Desktop、PC等场景下，开发Web应用产品并保障研发的工程质量与性能体验。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606449989,
"show_type": 3,
"is_show": 1,
"en_brief": "Develop web application products and ensure the quality and performance experience of R&D projects under scenarios such as Mobile, Desktop, PC, etc.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"highlight": {
"content": "<em>Flutter</em> 实战入门"
},
"item_set_info": {
"id": 0,
"item_id": "0",
"id_type": 0,
"title": "",
"brief": "",
"collect_cnt": 0,
"status": 0,
"ctime": 0,
"mtime": 0,
"cover": "",
"tag": 0,
"item_list": null,
"content_mtime": 0
},
"is_digg": false,
"is_collect": false,
"id_type": 24
},
{
"article_info": {
"title": "快速入门Flutter",
"author_id": 1000004664,
"comment_count": 0,
"content": "> 作者：赵辉（互娱研发-平台产品研发-多媒体）\n# Flutter概览\n## Flutter是什么\n> Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。 -- 来源：Flutter官网\n![image](https://tech-proxy.bytedance.net/tos/images/1584607318339_a41c0d6beee79b729b54159c13e259b3)\n\n## Flutter框架\n![image](https://tech-proxy.bytedance.net/tos/images/1584607338283_c6e161c88420adc4d8c5464048d3dadc)\n图片来源：技术社区\n###  Embedder\nEmbedder 是平台指定的语言实现，主要处理平台相关的操作，是为了 Flutter 能适配各种平台的嵌入层。Embedder 有 Android 的实现，也有 iOS 的实现，也有 Linux、MacOS、Windows 的实现。\n### Engine\nEngine 层由 C/C++ 实现，Flutter Engine 为 Flutter 应用提供了运行环境，是 Flutter 的核心。\n这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。\n### Framework\n这是一个纯 Dart实现的 SDK，它实现了一套基础库，自底向上：\n\n* 底下两层（Foundation和Animation、Painting、Gestures）在Google的一些视频中被合并为一个dart UI层，对应的是Flutter中的dart:ui包，它是Flutter引擎暴露的底层UI库，提供动画、手势及绘制能力。\n* Rendering层，这一层是一个抽象的布局层，它依赖于dart UI层，Rendering层会构建一个UI树，当UI树有变化时，会计算出有变化的部分，然后更新UI树，最终将UI树绘制到屏幕上，这个过程类似于React中的虚拟DOM。Rendering层可以说是Flutter UI框架最核心的部分，它除了确定每个UI元素的位置、大小之外还要进行坐标变换、绘制(调用底层dart:ui)。\n* Widgets层是Flutter提供的的一套基础组件库，在基础组件库之上，Flutter还提供了 Material 和Cupertino两种视觉风格的组件库。而我们Flutter开发的大多数场景，只是和这两层打交道。\n\n# 跨平台技术\n![image](https://tech-proxy.bytedance.net/tos/images/1584607460951_84ba422a162065ac2e4409805d96ba47)\n## Flutter自渲染\n![image](https://tech-proxy.bytedance.net/tos/images/1584607495098_7d30a9d4e08c3c4065fd108715d5b42e)\nRN\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607543603_a830d69077e275b9241c73597a55ee0f)\nFlutter\n\n安卓上面开启开发者选项的 “显示布局边界”，可以发现RN的界面是可以清楚看到页面布局结构，但是Flutter只有一整块，只是由于Flutter使用的是Skia直接渲染的，少了转换成Native那一步，如下图：\n![image](https://tech-proxy.bytedance.net/tos/images/1584607585626_efd56349f0c96043f86b0540d38cfdb4)\n这也正是Flutter高性能的原因之一\n## 性能对比\n**小米中端设备上性能对比**\n[https://bytedance.feishu.cn/file/boxcnfKatBEiUMuk2yiWhpfBdye](https://bytedance.feishu.cn/file/boxcnfKatBEiUMuk2yiWhpfBdye)\nRN 100 0000条数据\n[https://bytedance.feishu.cn/file/boxcnzO6Q7IZ8fgoFY3gD0IJdvc](https://bytedance.feishu.cn/file/boxcnzO6Q7IZ8fgoFY3gD0IJdvc)\nFlutter 1 0000 0000条数据\n# 项目结构\n## 目录\n![image](https://tech-proxy.bytedance.net/tos/images/1584607825906_8da04c3142f273387ca47c0b7045a884)\n- main.dart是入口文件\n- android 目录下是一个完整的 Android APP 工程的代码\n- ios 目录是一个完整的 iOS APP 工程的代码\n- lib 目录， Flutter 的代码，使用 Dart 语言编写\n- test 目录，Flutter 的测试代码，使用 Dart 语言编写\n- pubspec.yaml 配置，声明了 APP信息、依赖库、本地资源等\n\n## pubspec.yaml\n pubspec.yaml 支持的字段：\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584607895324_591fbd983de0e167d1181e9d11e6f9dc.png)\n# 声明式UI\n![image](https://tech-proxy.bytedance.net/tos/images/1584607916425_0bd700a8e9be7655319fd1457ee85219)\n在命令式风格中，你通常需要使用选择器 findViewById 或类似函数获取到 ViewB 的实例 b 和所有权，并调用相关的修改的方法（并隐式的使其失效）。例如：\n```\n// Imperative style\nb.setColor(red)\nb.clearChildren()\nViewC c3 = new ViewC(...)\nb.add(c3)\n```\n由于 UI 真实的来源可能比实例 b 本身的存活周期更长，你可能还需要在 ViewB 的构造函数中复制此配置。在声明式风格中，视图配置（如 Flutter 的 Widget ）是不可变的，它只是轻量的“蓝图”。要改变 UI，widget 会在自身上触发重建（在 Flutter 中最常见的方法是在 StatefulWidgets 组件上调用 setState()）并构造一个新的 Widget 子树。\n```\n// Declarative style\nreturn ViewB(\n  color: red,\n  child: ViewC(...),\n)\n```\n在这里，当用户界面发生变化时，Flutter 不会修改旧的实例 b，而是构造新的 widget 实例。框架使用 RenderObjects 管理传统 UI 对象的职责（比如维护布局的状态）。RenderObjects 在帧之间保持不变， Flutter 的轻量级 widget 通知框架在状态之间修改 RenderObjects， Flutter 框架则处理其余部分。\n**Flutter 构建的用户界面就是应用的当前状态。**\n# 核心原则\n## 一切皆 Widget\n- 一个结构元素（比如一个按钮或者菜单）\n- 一个风格元素（比如一个字体或者配色方案）\n- 布局的一个方面（比如 padding）\n- ……\n\n# Widgets\nFlutter 从 React 中吸取灵感，通过现代化框架创建出精美的组件。它的核心思想是用 widget 来构建你的 UI 界面。 Widget 描述了在当前的配置和状态下视图所应该呈现的样子。\n当 widget 的状态改变时，它会重新构建其描述（展示的 UI），框架则会对比前后变化的不同，以确定底层渲染树从一个状态转换到下一个状态所需的最小更改。\n```\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    Center(\n      child: Text(\n        'Hello, world!'\n      ),\n    ),\n  );\n}\n\n```\n## StatelessWidget\n```\nimport 'package:flutter/material.dart';\n\nclass StatelessWidgetPage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text('StatelessWidget'),\n        centerTitle: true,\n      ),\n      body: Center(\n        child: Text(\n          'Hello Flutter',\n          style: TextStyle(\n            fontSize: 58.0\n          ),\n        ),\n      ),\n    );\n  }\n}\n```\n\n## StatefulWidget\n```\nclass StatefulWidgetPage extends StatefulWidget {\n  StatefulWidgetPage({Key key}) : super(key: key);\n\n  @override\n  _StatefulWidgetPageState createState() => _StatefulWidgetPageState();\n}\n\nclass _StatefulWidgetPageState extends State<StatefulWidgetPage> {\n  int _count = 0;\n\n  void _add() {\n    setState(() {\n      _count += 1;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: Text( _count.toString()),\n      ),\n\n      floatingActionButton: FloatingActionButton(\n        onPressed: _add,\n        child: Icon(Icons.add),\n      ),\n    );\n  }\n}\n```\n## State里面的成员变量\n1. widget，可以访问StatefulWidget 中的成员变量\n2. context，上下文，BuildContext类型\n3. mounted，当前 State 是否加载到树里\n## 生命周期\n![image](https://tech-proxy.bytedance.net/tos/images/1584608130207_107c7c0a5dd4b9027550c905f05f731c)\n                  \n\n### initState\ninitState 方法是在创建 State 对象后要调用的第一个方法\n### didChangeDependencies\n  initState方法运行完后，就立即运行 didChangeDependencies 方法。\n  当 Widget 依赖的数据被调用时，此方法也会被调用\n### build\n- build() 方法在 didChangeDependencies（或者 didUpdateWidget）之后调用。 \n- 这是构建Widget的地方。\n- 调用setState强制重建\n- 触发build的一些方式：\n  - 路由的pop/push，用于进/出页面的动画\n  - 屏幕大小的调整，通常是由于键盘弹出或者屏幕方向改变、\n  - 父级Widget重新创建它的子Widget\n  - 窗口小部件依赖于（Class.of(context)模式）更改的InheritedWidget\n### didUpdateWidget\n当 Widget 重建后，新的 Widget 会和旧的 Widget 进行对比，如果新的 Widget 和旧的 Widget 的 runtimeType 和 Widget.key 都一样，那么就会调用 didUpdateWidget\n### deactive\n 当 State 从树中移除时，就会触发 deactive\n### dispose\n当 StatefulWidget 从树中移除时调用 dispose方法。\n 可以在这里执行一些清理逻辑（例如侦听器）\n\n- 注：StatelessWidget只有build一个生命周期\n\n# Dart语言\n- Dart 中的所有东西都是对象，包括数字、函数等，它们都继承自 Object，并且对象的默认值都是 null（包括数字）。\n- Dart 既可以支持 JIT（动态编译），也可以支持 AOT（静态编译）。\n- Dart 是强类型语言，但是由于 Dart 可以推断类型，所以也可以支持动态类型，例如 var、dynamic。\n- Dart 有强大的异步编程能力。\n## DartPad\n可以通过DartPad方便学习dart语言\n## 注释\n- /** **/ 多行注释\n- // 单行注释\n- /// 文档注释，在给变量、方法、类使用文档注释，IDE可以智能提示\n\n## final/const\nconst 是编译时常量，在编译的时候就初始化了，但是 final 变量是当类创建的时候才初始化。\n\n## 数据类型\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608343563_d12729ca9ba9c730be94cb8d514e57ff.png)\n## 函数\n在 Dart 中函数也是对象，函数的类型是 Function。\n```\n返回类型 函数名(函数参数){\n\n}\n```\n### 函数参数\n函数的参数分为两类：必选参数和可选参数\n#### 必选参数\n```\nString go(String name, String place) {\n    return '$name go to $place';\n}\n\ngo('Zhao', 'park'); // Zhao go to park\n```\n上面的name和place均是必选参数\n#### 可选参数\n可选参数分为可选命名参数和可选位置参数。\n##### 可选命名参数\n使用 {} 包起来的参数是可选命名参数\n```\nString go(String place, { String name }) {\n    return '${name ?? ''} go to $place';\n}\n\ngo('park'); // go to park\ngo('park', name: 'Zhao'); // Zhao go to park\n```\nname是可选的命名参数，如果要把命名参数也改成必选，可以加 @required\n```\nString go(String place, {@required String name }) {\n    return '$name go to $place';\n}\n```\n##### 可选位置参数\n用 [] 包起来的参数是可选位置参数\n```\nString go(String place, [String name]) {\n    return '${name ?? ''} go to $place';\n}\n\ngo('park'); // go to park\ngo('park', 'Zhao'); // Zhao go to park\n```\n##### 参数默认值\n```\nString go(String place, [ String name = 'Zhao' ]) {\n    return '$name go to $place';\n}\n\ngo('park'); // Zhao go to park\n```\n## 类Class\n### 构造函数\n```\nclass Point {  \n    num x, y;   \n\n    // 构造函数\n    Point(num x, num y) {\n        this.x = x;    \n        this.y = y;  \n    } \n}\n```\n构造函数的语法糖：\n```\nPoint(this.x, this.y);\n```\n## 操作符\n### 类型判断操作符\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608743121_974a1706a0777d04d8d9fc6a75d17ec1.png)\n### 赋值操作符\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608793186_89a206601a805bd69bfdecd2cd6d1ad0.png)\n### 条件运算符\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608823804_fc366b1581be4433a69928b890572ee8.png)\n### 级联操作符\n```\nquerySelector('#confirm')\n    ..text = 'Confirm'\n    ..classes.add('important')  \n    ..onClick.listen((e) => window.alert('Confirmed!'));\n```\n### 其他\n\n|操作符  |含义  | 示意 |\n| --- | --- | --- |\n| ?. |有条件的成员变量访问  |foo?.bar，如果 foo 为 null，则不会抛异常，而是返回 null  |\n\n# 状态管理\n![image](https://tech-proxy.bytedance.net/tos/images/1584610587609_aeaf90036c55ae90d7d057030c7e0432)\n\n常见的几种状态管理：\n- InheritedWidget\n- Scoped model\n- BLoC\n- Redux\n- Provider\n\n# json和序列化\n\n# Flutter 特性总结\n1. 跨平台\n  - Android\n  - iOS\n  - PC 端：Windows、Linux、MacOS。\n  - WEB 端：WEB 端已经发布了技术预览版\n  - Fuchsia：Fuchsia的用户界面与应用使用Flutter开发\n2. 高性能\n  - 界面可以达到 60 FPS ，渲染效率和用户体验堪比 Native。\n  - Flutter 应用在 Release 下会编译成 Native ARM code ，使得跨平台的代码运行效率很高。\n  - Native 和 Flutter 之间是通过 JNI 桥接的，也使得 Native 和 Flutter 之间交互的损耗很低。\n3. 丰富的 UI 组件：\n- Flutter 内置众多精美的 Material Design（Android风格）和 Cupertino（iOS风格）的小部件，而且 UI 样式高度还原 Native 的样式，可以让我们直接使用，而且这些组件都很方便组合，还有丰富的动画库。\n4. 学习成本低\n- Flutter 的学习成本很低，屏蔽了底层的很多实现，可以很快的入手\n5. 开发效率高\n- Flutter 拥有丰富的 UI 部件，而且支持 Hot Reload，同时 Flutter 使用 Dart 语言开发，Dart 具备很多新的语言特性，可以使得开发速度很快。\n6. 和任何平台的交互都很方便\n- 由于 Flutter 的架构设计，使得 Flutter 可以在任何平台扩展，也可以和平台很方便的交互，从而可以让 Flutter 使用平台的功能。\n7. Write once,Run everywhere\n- 只要写一份代码，就可以构建出 Android 和 iOS 两个平台的 APP，体验能达到和原生应用一致，真正做到「Write once , Run everywhere.」\n\n",
"ctime": 1584612300,
"mtime": 1621410281,
"commentable": 0,
"status": 0,
"dig_cnt": 5,
"collect_cnt": 2,
"cover_url": "",
"brief": "",
"article_id": "6805843068156117000",
"draft_id": "6805822407123664910",
"view_cnt": 149,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "Quick Start Flutter\n",
"en_content": "> Author: Zhao Hui (mutual entertainment R & D-platform product R & D-multimedia)\n\n# Flutter Overview\n\n## What's Flutter?\n\n> Flutter is Google's open source UI toolkit that helps developers efficiently build beautiful multi-platform applications through a code base that supports mobile, web, desktop and embedded platforms ｡ -- source: Flutter official website\n> ![image](https://tech-proxy.bytedance.net/tos/images/1584607318339\\_a41c0d6beee79b729b54159c13e259b3)\n\n## Flutter Framework\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607338283\\_c6e161c88420adc4d8c5464048d3dadc)\nPhoto Credit: Tech Community\n\n### Embedder\n\nEmbedder is a language implementation specified by the platform. It mainly handles platform-related operations so that Flutter can adapt to the embedding layer of various platforms. Embedder has the implementation of Android, iOS, Linux, MacOS, and Windows.\n\n### Engine\n\nThe Engine layer is implemented by C/C++. Flutter Engine provides a running environment for Flutter applications and is the core of Flutter.\nThis is a pure C ++ SDK, which includes the Skia engine, Dart runtime, text layout engine, etc. When the code calls the dart: ui library, the call will eventually go to the Engine layer, and then implement the real drawing logic.\n\n### Framework\n\nThis is a pure Dart implementation of the SDK, which implements a set of basic libraries, from the bottom up:\n\n*   The bottom two layers (Foundation and Animation, Painting, and Gestures) are merged into a dart UI layer in some Google videos, corresponding to the dart: ui package in Flutter, which is the underlying UI library exposed by the Flutter engine and provides animation, gestures, and drawing capabilities.\n*   Rendering layer, this layer is an abstract layout layer, which relies on the dart UI layer. Rendering layer will build a UI tree. When the UI tree changes, the accountant calculates the changed part, then updates the UI tree, and finally draws the UI tree to the screen. This process is similar to the virtual DOM in React. The Rendering layer can be said to be the core part of the Flutter UI framework. In addition to determining the location and size of each UI element, it also needs to perform coordinate transformation and drawing (call the underlying dart: ui).\n*   The Widgets layer is a set of basic component libraries provided by Flutter. On top of the basic component library, Flutter also provides two visual style component libraries of Material and Cupertino. Most of the scenarios we develop in Flutter only deal with these two layers.\n\n# Cross-platform technology\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607460951\\_84ba422a162065ac2e4409805d96ba47)\n\n## Flutter self-rendering\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607495098\\_7d30a9d4e08c3c4065fd108715d5b42e)\nRN\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607543603\\_a830d69077e275b9241c73597a55ee0f)\nFlutter\n\nAndroid above open the developer option \"display layout boundary,\" you can find that the RN interface can clearly see the page layout structure, but Flutter only has a whole block, just because Flutter uses Skia to render directly, without the step of converting to Native, as shown in the following figure:\n![image](https://tech-proxy.bytedance.net/tos/images/1584607585626\\_efd56349f0c96043f86b0540d38cfdb4)\nThis is one of the reasons why Flutter is high-performance\n\n## Performance Comparison\n\n**Performance Comparison on Xiaomi Mid-range Devices**\n<https://bytedance.feishu.cn/file/boxcnfKatBEiUMuk2yiWhpfBdye>\nRN 100 0000 data\n<https://bytedance.feishu.cn/file/boxcnzO6Q7IZ8fgoFY3gD0IJdvc>\nFlutter  1 0000 0000 data\n\n# Project structure\n\n## Catalog\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607825906\\_8da04c3142f273387ca47c0b7045a884)\n\n*   main.dart the entry file\n*   Android directory is a complete Android APP project code\n*   The iOS directory is a complete iOS APP project code\n*   Lib directory, Flutter code, written in Dart language\n*   Test directory, Flutter test code, written in Dart language\n*   pubspec.yaml configuration, declaring APP information, dependency libraries, local resources, etc\n\n## pubspec.yaml\n\npubspec.yaml supported fields:\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584607895324\\_591fbd983de0e167d1181e9d11e6f9dc.png)\n\n# Declarative UI\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584607916425\\_0bd700a8e9be7655319fd1457ee85219)\nIn the command style, you usually need to use the selector findViewById or similar function to get the instance b and ownership of ViewB, and call the related modified method (and implicitly invalidate it). For example:\n\n    // Imperative style\n    b.setColor(red)\n    b.clearChildren()\n    ViewC c3 = new ViewC(...)\n    b.add(c3)\n\nSince the real source of the UI may have a longer lifespan than instance b itself, you may also need to copy this configuration in ViewB's constructor. In a declarative style, the view configuration (such as Flutter's Widget) is immutable, it is just a lightweight \"blueprint.\" To change the UI, the widget triggers a rebuild on itself (the most common method in Flutter is to call setState () on the StatefulWidgets component) and construct a new Widget subtree.\n\n    // Declarative style\n    return ViewB(\n      color: red,\n      child: ViewC(...),\n    )\n\nHere, when the user interface changes, Flutter does not modify the old instance b, but constructs a new widget instance. The framework uses RenderObjects to manage the responsibilities of traditional UI objects (such as maintaining the state of the layout). RenderObjects remain unchanged between frames, Flutter's lightweight widget notification framework modifies RenderObjects between states, and the Flutter framework handles the rest.\n**The user interface built by Flutter is the current state of the application.**\n\n# Core principles\n\n## Widget everything\n\n*   A structural element (such as a button or menu)\n*   A style element (such as a font or color scheme)\n*   An aspect of layout (such as padding)\n*   ……\n\n# Widgets\n\nFlutter draws inspiration from React to create beautiful components through a modern framework. Its core idea is to build your UI interface with widgets. Widgets describe what views should look like in the current configuration and state.\nWhen the state of the widget changes, it rebuilds its description (the UI shown), and the framework compares the changes before and after to determine the minimum change required for the underlying rendering tree to transition from one state to the next.\n\n```\nimport 'package:flutter/material.dart';\n\nvoid main() {\n  runApp(\n    Center(\n      child: Text(\n        'Hello, world!'\n      ),\n    ),\n  );\n}\n\n```\n\n## StatelessWidget\n\n    import 'package:flutter/material.dart';\n\n    class StatelessWidgetPage extends StatelessWidget {\n      @override\n      Widget build(BuildContext context) {\n        return Scaffold(\n          appBar: AppBar(\n            title: Text('StatelessWidget'),\n            centerTitle: true,\n          ),\n          body: Center(\n            child: Text(\n              'Hello Flutter',\n              style: TextStyle(\n                fontSize: 58.0\n              ),\n            ),\n          ),\n        );\n      }\n    }\n\n## StatefulWidget\n\n    class StatefulWidgetPage extends StatefulWidget {\n      StatefulWidgetPage({Key key}) : super(key: key);\n\n      @override\n      _StatefulWidgetPageState createState() => _StatefulWidgetPageState();\n    }\n\n    class _StatefulWidgetPageState extends State<StatefulWidgetPage> {\n      int _count = 0;\n\n      void _add() {\n        setState(() {\n          _count += 1;\n        });\n      }\n\n      @override\n      Widget build(BuildContext context) {\n        return Scaffold(\n          body: Center(\n            child: Text( _count.toString()),\n          ),\n\n          floatingActionButton: FloatingActionButton(\n            onPressed: _add,\n            child: Icon(Icons.add),\n          ),\n        );\n      }\n    }\n\n## Member variables in State\n\n1.  Widget with access to member variables in the StatefulWidget\n2.  Context, context, BuildContext type\n3.  Mounted, whether the current State is loaded into the tree\n\n## Life cycle\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584608130207\\_107c7c0a5dd4b9027550c905f05f731c)\n\n### initState\n\nThe initState method is the first method to be called after the State object is created\n\n### didChangeDependencies\n\nThe didChangeDependencies method runs as soon as the initState method runs.\nThis method is also called when the widget-dependent data is called\n\n### build\n\n*   The build () method is called after didChangeDependencies (or didUpdateWidget).\n*   This is where the widget is built.\n*   Call setState to force rebuild\n*   Some ways to trigger build:\n    *   Routed pop/push for in / out page animation\n    *   Screen size adjustment, usually due to keyboard pop-up or screen direction change,\n    *   The parent widget recreates its child widget\n    *   Widget dependent on (Class.of (context) mode) changes InheritedWidget\n\n### didUpdateWidget\n\nWhen the widget is rebuilt, the new widget will be compared with the old widget. If the runtimeType and Widget.key of the new widget and the old widget are the same, didUpdateWidget will be called\n\n### deactive\n\nDeactive is triggered when State is removed from the tree\n\n### dispose\n\nCall the dispose method when the StatefulWidget is removed from the tree.\nYou can perform some cleaning logic here (for example, listeners)\n\n*   Note: StatelessWidget has only one build lifecycle\n\n# Dart language\n\n*   Everything in Dart is an object, including numbers, functions, etc. They all inherit from Object, and the default value of the object is null (including numbers).\n*   Dart can support both JIT (dynamic compilation) and AOT (static compilation).\n*   Dart is a strongly typed language, but because Dart can infer types, it can also support dynamic types, such as var and dynamic.\n*   Dart has strong asynchronous programming capabilities.\n\n## DartPad\n\nYou can easily learn the dart language through DartPad\n\n## Comment\n\n*   /\\*\\* \\*\\*/ multiline comments\n*   // single-line comment\n*   /// document annotations. When using document annotations for variables, methods, and classes, the IDE can intelligently prompt\n\n## final/const\n\nConst is a compile-time constant that is initialized at compile time, but final variables are initialized when the class is created.\n\n## Data type\n\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608343563\\_d12729ca9ba9c730be94cb8d514e57ff.png)\n\n## Function\n\nIn Dart, a function is also an object, and the type of the function is Function.\n\n    Return type, function name (function parameter) {\n\n    }\n\n### Function parameter\n\nThe parameters of the function are divided into two categories: required parameters and optional parameters\n\n#### Required parameter\n\n    String go(String name, String place) {\n        return '$name go to $place';\n    }\n\n    go('Zhao', 'park'); // Zhao go to park\n\nThe name and place above are required parameters\n\n#### Optional parameter\n\nOptional parameters are divided into optional named parameters and optional location parameters.\n\n##### Optional named parameters\n\nParameters wrapped with {} are optional named parameters\n\n    String go(String place, { String name }) {\n        return '${name ?? ''} go to $place';\n    }\n\n    go('park'); // go to park\n    go('park', name: 'Zhao'); // Zhao go to park\n\nName is an optional naming parameter. If you want to change the naming parameter to mandatory, you can add @required\n\n    String go(String place, {@required String name }) {\n        return '$name go to $place';\n    }\n\n##### Optional position parameters\n\nParameters wrapped in \\[] are optional location parameters\n\n    String go(String place, [String name]) {\n        return '${name ?? ''} go to $place';\n    }\n\n    go('park'); // go to park\n    go('park', 'Zhao'); // Zhao go to park\n\n##### Parameter defaults\n\n    String go(String place, [ String name = 'Zhao' ]) {\n        return '$name go to $place';\n    }\n\n    go('park'); // Zhao go to park\n\n## Class\n\n### Constructor\n\n    Point of class of class {\n    Num x, y;\n\n    // constructor\n    Point (num x, num y) {\n    This.x = x;\n    This.y = y;\n    }\n    }\n\nSyntax sugar of constructor:\n\n    Point(this.x, this.y);\n\n## Operator\n\n### Type judgment operator\n\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608743121\\_974a1706a0777d04d8d9fc6a75d17ec1.png)\n\n### Assignment operator\n\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608793186\\_89a206601a805bd69bfdecd2cd6d1ad0.png)\n\n### Article operator\n\n![image.png](https://tech-proxy.bytedance.net/tos/images/1584608823804\\_fc366b1581be4433a69928b890572ee8.png)\n\n### Cascade operator\n\n    querySelector('#confirm')\n        ..text = 'Confirm'\n        ..classes.add('important')  \n        ..onClick.listen((e) => window.alert('Confirmed!'));\n\n### Other\n\n| Operator | Meaning | Schematic |\n| --- | --- | --- |\n| ?.| conditional member variable access | foo?.bar, if foo is null, no exception will be thrown, but null | will be returned.\n\n# State management\n\n![image](https://tech-proxy.bytedance.net/tos/images/1584610587609\\_aeaf90036c55ae90d7d057030c7e0432)\n\nSeveral common state management:\n\n*   InheritedWidget\n*   Scoped model\n*   BLoC\n*   Redux\n*   Provider\n\n# Json and serialization\n\n# Flutter Feature Summary\n\n1.  Cross-platform\n\n*   Android\n*   iOS\n*   PC: Windows, Linux, MacOS.\n*   WEB side: The WEB side has released a technical preview\n*   Fuchsia: Fuchsia user interface and application development using Flutter\n\n2.  High performance\n\n*   The interface can reach 60 FPS, rendering efficiency and user experience comparable to Native.\n*   Flutter applications are compiled into Native ARM code under Release, making cross-platform code efficient.\n*   Native and Flutter are bridged through JNI, which also makes the interaction between Native and Flutter very low loss.\n\n3.  Rich UI components:\n\n*   Flutter has built-in many exquisite Material Design (Android style) and Cupertino (iOS style) widgets, and the UI style is highly restored to Native style, which can be used directly by us, and these components are easy to combine, and there is a rich animation library.\n\n4.  Low learning costs\n\n*   Flutter's learning cost is very low, shielding many of the underlying implementations, and it can be started quickly\n\n5.  High development efficiency\n\n*   Flutter has rich UI components and supports Hot Reload. At the same time, Flutter is developed in the Dart language. Dart has many new language features that can make development fast.\n\n6.  Easy to interact with any platform\n\n*   Due to Flutter's architecture design, Flutter can be extended on any platform and can easily interact with the platform, so that Flutter can use the platform's functions.\n\n7.  Write once,Run everywhere\n\n*   As long as you write a code, you can build Android and iOS two platform APP, experience can achieve the same as the native application, truly \"Write once, Run everywhere.\"\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "吴阳",
"full_name": "吴阳",
"email": "wuyang.088@bytedance.com",
"employee_id": 1000004664,
"lark_id": "6615020887642996999",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/01b0dc81-ca62-4290-92f9-b9b690587e2g~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 2,
"follower_count": 302,
"digg_cnt": 2585,
"lark_open_id": "9d469e59",
"auth": 6,
"department_name": "产品研发和工程架构部-技术学院-内部社区",
"intro": "好好活着",
"roleIds": [
3,
2
],
"score": 10077,
"status": 1,
"answer_digg_cnt": 1065,
"question_cnt": 1000,
"answer_cnt": 1171,
"is_follow": false,
"collect_cnt": 1276,
"xid": "cb8466dd89e9dc3f7ec671e68389c7c5",
"participate_time": 0,
"badge": {
"Activity": 1,
"ArticleAndVideo": 0,
"PointOfView": 1
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064991090",
"name": "产品研发和工程架构部-技术学院-内部社区",
"en_name": "Product RD and Infrastructure-Tech Academy-Byte Community"
},
"sequence_v2": {
"id": 24,
"name": "运营",
"en_name": "Operations"
},
"en_name": "Yang Wu",
"leader": {
"id": 1369918,
"name": "吴亮",
"u_name": "吴亮 (wuliang.akira)",
"email": "wuliang.akira@bytedance.com",
"employee_number": 1369918,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 7160779,
"entry_date": 1540166400
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 5,
"name": "Flutter",
"follow_count": 3678,
"item_count": 119,
"en_name": "Flutter",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "> 作者：赵辉（互娱研发-平台产品研发-多媒体）\n# <em>Flutter</em>概览\n## <em>Flutter</em>是什么\n> <em>Flutter</em> 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库高效构建多平台精美应用...### Engine\nEngine 层由 C/C++ 实现，<em>Flutter</em> Engine 为 <em>Flutter</em> 应用提供了运行环境，是 <em>Flutter</em> 的核心。"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
},
{
"article_info": {
"title": "Flutter外接纹理",
"author_id": 1000009077,
"comment_count": 0,
"content": "\n\n# 一、背景\n\nFlutter是Google推出的一个跨平台移动应用框架，使用Skia作为其渲染引擎直接绘制UI，日常开发中大部分UI均可在Dart层直接实现。但涉及到视频播放、美颜等功能时，Dart层就显得无能为力了。因此，Flutter提供了一套外接纹理的机制来解决此类问题。\n\n# 二、Flutter渲染机制简介\n\nAndroid中通常是通过编写xml文件来进行布局，通过layoutInflater的inflate方法对xml进行解析并构建出View树。而在Flutter中，布局的构建是由一系列的Widget嵌套组装成Widget树，但widget仅仅是保存了布局的信息，真正负责渲染的是renderObject，layout和paint过程均由其控制。在widget和renderObject之间有一个Element，它同时持有widget和renderObject，负责遍历视图树。当视图需要更新时，widget树会重建，而element则会根据具体情况进行复用，实现局部更新。\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/e8c6e8c11b3f40918b130bb8c4a792e4~tplv-noop.png?width=1200&height=697)\n\n当页面需要渲染的时候，会在Flutter Engine注册一个Vsync信号回调。一旦收到Vsync信号，会回调UI线程，开始进行build(), layout(), paint()操作，最终构建出一个 layer tree。由于Flutter的跨平台性，具体如何绘制视图取决于平台的具体实现，比如OpenGL、Vulkan等。layer tree仅保存了绘制所需的信息，需要通过GPU线程将其转化成具体的GPU指令，供不同平台进行绘制。\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/e274f767b98744b1ade994dca422a0fb~tplv-noop.png?width=1200&height=1069)\n\n  \n\n# 三、Flutter外接纹理原理浅析\n\n所谓外接纹理实际上就是提供一个surfaceTexture，视频源、相机等数据源作为生产端输出到Surface上，GLConsumer作为消费端最终将数据转换成GL纹理。在Flutter中，提供了一个Texture Widget，它通过PlatformChannel与该surfaceTexture建立起对应关系。该Texture在渲染的时候的数据来源便来自surfacetexture。\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/0fc0d39a66ae4ec4a4cfddae0774efc5~tplv-noop.png?width=1200&height=537)\n\nTexture对应的renderObject的paint方法实际会创建一个新的layer--TextureLayer：\n```dart\n@override\nvoid paint(PaintingContext context, Offset offset) {\n  if (_textureId == null)\n    return;\n  context.addLayer(TextureLayer(\n    rect: Rect.fromLTWH(offset.dx, offset.dy, size.width, size.height),\n    textureId: _textureId,\n  ));\n}\n```\nFlutter中的widget最终会形成一棵Layer Tree，在GPU线程中会遍历layer tree，依次执行每个layer的paint操作，最终转变成相应的GPU指令。而TextureLayer的paint方法如下：\n```cc\nvoid TextureLayer::Paint(PaintContext& context) const {\n  std::shared_ptr<Texture> texture =\n      context.texture_registry.GetTexture(texture_id_);\n  if (!texture) {\n    return;\n  }\n  texture->Paint(*context.leaf_nodes_canvas, paint_bounds(), freeze_,\n                 context.gr_context);\n}\n```\n可以看出会通过texture id取出Texture，再调用texture的paint方法。那么这个texture从哪来的呢，实际上就是我们在Java层创建后再经过JNI注册进texture\\_registry的。\n```java\nTextureRegistry.SurfaceTextureEntry entry = textureRegistry.createSurfaceTexture();\n\n// FlutterView\npublic SurfaceTextureEntry createSurfaceTexture() {\n    SurfaceTexture surfaceTexture = new SurfaceTexture(0);\n    surfaceTexture.detachFromGLContext();\n    FlutterView.SurfaceTextureRegistryEntry entry = new FlutterView.SurfaceTextureRegistryEntry(this.nextTextureId.getAndIncrement(), surfaceTexture);\n    this.mNativeView.getFlutterJNI().registerTexture(entry.id(), surfaceTexture);\n    return entry;\n}\n\n// FlutterJNI\nprivate native void nativeRegisterTexture(long var1, long var3, SurfaceTexture var5);\n```\n可以看出在这里创建了一个SurfaceTexture，并赋予了其一个特定的id，最后通过FlutterJNI的nativeRegisterTexture方法将该SurfaceTexture和id传递到引擎层。该方法为native方法，在flutter初始化时会通过JNI\\_OnLoad注册。\n```cc\n//library_loader.cc\nJNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {\n  ...\n  // Register PlatformView\n  result = flutter::PlatformViewAndroid::Register(env);\n  ...\n}\n\n//platform_view_android_jni.cc\nbool PlatformViewAndroid::Register(JNIEnv* env) {\n  g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef<jclass>(\n    env, env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\"));\n  if (g_flutter_jni_class->is_null()) {\n    return false;\n  }\n  return RegisterApi(env);\n}\n\nbool RegisterApi(JNIEnv* env) {  \n  static const JNINativeMethod flutter_jni_methods[] = {\n    ...\n    {\n        .name = \"nativeRegisterTexture\",\n        .signature = \"(JJLandroid/graphics/SurfaceTexture;)V\",\n        .fnPtr = reinterpret_cast<void*>(&RegisterTexture),\n    },\n    ...\n  }\n  if (env->RegisterNatives(g_flutter_jni_class->obj(), flutter_jni_methods,\n                         fml::size(flutter_jni_methods)) != 0) {\n    FML_LOG(ERROR) << \"Failed to RegisterNatives with FlutterJNI\";\n    return false;\n  }\n  ...\n}\n```\n这里简单介绍一下JNI注册的流程：\nJava层调用System.loadLibray()方法最终会调用到C++层中的JNI\\_OnLoad方法，在该方法会完成Java方法的注册。\n\n1.  通过JNIEnv->findClass()找到所要注册的Java类的引用\n\n2.  定义一个数组存储该类所要注册的方法，每个方法包含name，signature和fnPtr三种。name为方法的名称，signature为方法的签名，括号内是方法的参数类型，括号后面是方法的返回类型。下面是参数类型的对应表。fnPtr则是所要注册的方法在native层对应的实现方法的指针。\n\n*     \n    \n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/55e322af64cf4f13a9a6f3607bf7292f~tplv-noop.png?width=818&height=486)\n\n3.  调用 env -> RegisterNatives(jclazz, gMethods, sizeof(gMethods)/ sizeof(gMethods\\[0\\]))，第一个参数是步骤1得到的Java类，第二个参数是步骤2定义的方法数组，第三个参数的方法数量。\n\n  \n\n可以看出该native方法最终调用到的是RegisterTexture这个方法。\n```cc\n//platform_view_android_jni.cc\nstatic void RegisterTexture(JNIEnv* env,\n                            jobject jcaller,\n                            jlong shell_holder,\n                            jlong texture_id,\n                            jobject surface_texture) {\n  ANDROID_SHELL_HOLDER->GetPlatformView()->RegisterExternalTexture(\n      static_cast<int64_t>(texture_id),                        //\n      fml::jni::JavaObjectWeakGlobalRef(env, surface_texture)  //\n  );\n}\n\n//platform_view_android.cc\nvoid PlatformViewAndroid::RegisterExternalTexture(\n    int64_t texture_id,\n    const fml::jni::JavaObjectWeakGlobalRef& surface_texture) {\n  RegisterTexture(\n      std::make_shared<AndroidExternalTextureGL>(texture_id, surface_texture));\n}\n\n//texture.cc\nvoid TextureRegistry::RegisterTexture(std::shared_ptr<Texture> texture) {\n  mapping_[texture->Id()] = texture;\n}\n```\n最终将该surfacetexture和id建立起一个映射关系存入了TextureRegistry的map中。后续TextureLayer执行paint方法时便会从该map中取出surfacetexture并进行渲染。\n整体流程图：\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/4771b81175024a649fe4cb155b34babf~tplv-noop.png?width=1182&height=840)\n\n  \n\n# 四、实例\n\n```dart\n// Dart层\nclass _MyHomePageState extends State<MyHomePage> {\n  MethodChannel _channel = MethodChannel('flutter.texture.demo');\n  int _textureId = 0;\n\n  @override\n  void initState() {\n    _init();\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(widget.title),\n      ),\n      body: Column(\n        mainAxisAlignment: MainAxisAlignment.start,\n        children: <Widget>[\n          Container(\n            height: 250,\n            color: Colors.blue,\n            child: Texture(textureId: _textureId),\n          ),\n          FlatButton(\n            onPressed: _draw,\n            color: Colors.blue,\n            child: Text(\n              'play'\n            ),\n          )\n        ],\n      ), // This trailing comma makes auto-formatting nicer for build methods.\n    );\n  }\n\n  void _init() async {\n    _textureId = await _channel.invokeMethod('init');\n    setState(() {\n\n    });\n  }\n\n  void _draw() {\n    _channel.invokeMethod('play');\n  }\n}\n\n//Java层\n@Override\npublic void onMethodCall(MethodCall methodCall, MethodChannel.Result result) {\n    switch (methodCall.method) {\n        case \"init\":\n            TextureRegistry textureRegistry = mRegistrar.textures();\n            TextureRegistry.SurfaceTextureEntry entry = textureRegistry.createSurfaceTexture();\n            mSurface = new Surface(entry.surfaceTexture());\n            initPlayer();\n            result.success(entry.id());\n            return;\n        case \"play\":\n            play();\n            result.success(null);\n            return;\n    }\n    result.notImplemented();\n}\n\nprivate void initPlayer() {\n    mPlayer = new MediaPlayer();\n    try {\n        mPlayer.setDataSource(\"https://clips.vorwaerts-gmbh.de/big_buck_bunny.mp4\");\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n    mPlayer.setSurface(mSurface);\n}\n\nprivate void play() {\n    try {\n        mPlayer.prepare();\n        mPlayer.start();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n[最终效果：](http://sf1-hscdn-tos.pstatp.com/obj/vcloud/3fdf48cc10cc65fa096d09704be313b7-.mp4)\n<p class=\"img-tip\" data-str=\"\"><img src=\"https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/ccb2333962134023a883155ed3f7dcfe~noop.png\" height=\"1884\" width=\"894\"/></p>\n\n",
"ctime": 1567169396,
"mtime": 1621765232,
"commentable": 0,
"status": 0,
"dig_cnt": 0,
"collect_cnt": 2,
"cover_url": "",
"brief": "",
"article_id": "8442",
"draft_id": "6920191448436441095",
"view_cnt": 3637,
"point_score": 0,
"answer_count": 0,
"id_type": 8,
"parent_id": "0",
"en_title": "Flutter external texture\n",
"en_content": "# I. Background\n\nFlutter is a cross-platform mobile application framework launched by Google. Skia is used as its rendering engine to directly draw the UI. Most of the UI in daily development can be directly implemented in the Dart layer. However, when it comes to video playback, beauty and other functions, the Dart layer is powerless. Therefore, Flutter provides a set of external texture mechanisms to solve such problems.\n\n# Introduction to Flutter Rendering Mechanism\n\nIn Android, the layout is usually done by writing an xml file, parsing the xml and building a View tree through the inflate method of layoutInflater. In Flutter, the layout is built by a series of widgets nested and assembled into a Widget tree, but the widget only saves the layout information, and the real person responsible for rendering is renderObject, which controls the layout and paint process. There is an Element between the widget and renderObject, which holds both the widget and renderObject and is responsible for traversing the view tree. When the view needs to be updated, the widget tree will be rebuilt, and the element will be reused according to the specific situation to achieve local updates.\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/e8c6e8c11b3f40918b130bb8c4a792e4~tplv-noop.png?width=1200\\&height=697)\n\nWhen the page needs to be rendered, a Vsync signal callback will be registered in the Flutter Engine. Once the Vsync signal is received, the UI thread will be called back to start the build (), layout (), paint () operation, and finally build a layer tree. Due to the cross-platform nature of Flutter, how to draw the view depends on the specific implementation of the platform, such as OpenGL, Vulkan, etc. The layer tree only saves the information needed for drawing, and needs to be converted into specific GPU instructions through the GPU thread for different platforms to draw.\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/e274f767b98744b1ade994dca422a0fb~tplv-noop.png?width=1200\\&height=1069)\n\n# Three, Flutter external texture principle analysis\n\nThe so-called external texture is actually to provide a surfaceTexture. Data sources such as video sources and cameras are output to the Surface as the production end, and GLConsumer is used as the consumer end to finally convert the data into a GL texture. In Flutter, a Texture Widget is provided, which establishes a corresponding relationship with the surfaceTexture through the PlatformChannel. The data source of the Texture when rendering comes from surfacetexture.\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/0fc0d39a66ae4ec4a4cfddae0774efc5~tplv-noop.png?width=1200\\&height=537)\n\nTexture renderObject's paint method actually creates a new layer--TextureLayer:\n\n```dart\n@override\nvoid paint(PaintingContext context, Offset offset) {\n  if (_textureId == null)\n    return;\n  context.addLayer(TextureLayer(\n    rect: Rect.fromLTWH(offset.dx, offset.dy, size.width, size.height),\n    textureId: _textureId,\n  ));\n}\n```\n\nThe widget in Flutter will eventually form a Layer Tree, which will traverse the layer tree in the GPU thread, execute the paint operations of each layer in turn, and finally transform into the corresponding GPU instructions. The paint method of TextureLayer is as follows:\n\n```cc\nvoid TextureLayer::Paint(PaintContext& context) const {\n  std::shared_ptr<Texture> texture =\n      context.texture_registry.GetTexture(texture_id_);\n  if (!texture) {\n    return;\n  }\n  texture->Paint(*context.leaf_nodes_canvas, paint_bounds(), freeze_,\n                 context.gr_context);\n}\n```\n\nIt can be seen that Texture will be taken out through the texture id, and then the paint method of texture will be called. So where did this texture come from? In fact, we created it in the Java layer and then registered it into the texture_registry through JNI.\n\n```java\nTextureRegistry.SurfaceTextureEntry entry = textureRegistry.createSurfaceTexture();\n\n// FlutterView\npublic SurfaceTextureEntry createSurfaceTexture() {\n    SurfaceTexture surfaceTexture = new SurfaceTexture(0);\n    surfaceTexture.detachFromGLContext();\n    FlutterView.SurfaceTextureRegistryEntry entry = new FlutterView.SurfaceTextureRegistryEntry(this.nextTextureId.getAndIncrement(), surfaceTexture);\n    this.mNativeView.getFlutterJNI().registerTexture(entry.id(), surfaceTexture);\n    return entry;\n}\n\n// FlutterJNI\nprivate native void nativeRegisterTexture(long var1, long var3, SurfaceTexture var5);\n```\n\nIt can be seen that a SurfaceTexture is created here and given a specific id. Finally, the SurfaceTexture and id are passed to the engine layer through FlutterJNI's nativeRegisterTexture method. This method is a native method and will be registered through the JNI_OnLoad when flutter is initialized.\n\n```cc\n//library_loader.cc\nJNIEXPORT jint JNI_OnLoad(JavaVM* vm, void* reserved) {\n  ...\n  // Register PlatformView\n  result = flutter::PlatformViewAndroid::Register(env);\n  ...\n}\n\n//platform_view_android_jni.cc\nbool PlatformViewAndroid::Register(JNIEnv* env) {\n  g_flutter_jni_class = new fml::jni::ScopedJavaGlobalRef<jclass>(\n    env, env->FindClass(\"io/flutter/embedding/engine/FlutterJNI\"));\n  if (g_flutter_jni_class->is_null()) {\n    return false;\n  }\n  return RegisterApi(env);\n}\n\nbool RegisterApi(JNIEnv* env) {  \n  static const JNINativeMethod flutter_jni_methods[] = {\n    ...\n    {\n        .name = \"nativeRegisterTexture\",\n        .signature = \"(JJLandroid/graphics/SurfaceTexture;)V\",\n        .fnPtr = reinterpret_cast<void*>(&RegisterTexture),\n    },\n    ...\n  }\n  if (env->RegisterNatives(g_flutter_jni_class->obj(), flutter_jni_methods,\n                         fml::size(flutter_jni_methods)) != 0) {\n    FML_LOG(ERROR) << \"Failed to RegisterNatives with FlutterJNI\";\n    return false;\n  }\n  ...\n}\n```\n\nHere is a brief introduction to the JNI registration process:\nA Java layer call to the System.loadLibray () method ends up calling the JNI_OnLoad method in the C ++ layer, where the Java method registration is completed.\n\n1.  Find a reference to the Java class you want to register through JNIEnv- > findClass ()\n\n2.  Define an array to store the methods to be registered by this class. Each method contains three types: name, signature, and fnPtr. Name is the name of the method, signature is the signature of the method, the parameter type of the method is in parentheses, and the return type of the method is followed by parentheses. The following is the correspondence table of the parameter types. fnPtr is the pointer to the implementation method corresponding to the method to be registered at the native layer.\n\n*\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/55e322af64cf4f13a9a6f3607bf7292f~tplv-noop.png?width=818\\&height=486)\n\n3.  Call env -> RegisterNatives (jclazz, gMethods, sizeof (gMethods) / sizeof (gMethods \\[0 ])), The first parameter is the Java class obtained in step 1, the second parameter is the method array defined in step 2, and the number of methods for the third parameter.\n\nIt can be seen that the native method finally calls the RegisterTexture method.\n\n```cc\n//platform_view_android_jni.cc\nstatic void RegisterTexture(JNIEnv* env,\n                            jobject jcaller,\n                            jlong shell_holder,\n                            jlong texture_id,\n                            jobject surface_texture) {\n  ANDROID_SHELL_HOLDER->GetPlatformView()->RegisterExternalTexture(\n      static_cast<int64_t>(texture_id),                        //\n      fml::jni::JavaObjectWeakGlobalRef(env, surface_texture)  //\n  );\n}\n\n//platform_view_android.cc\nvoid PlatformViewAndroid::RegisterExternalTexture(\n    int64_t texture_id,\n    const fml::jni::JavaObjectWeakGlobalRef& surface_texture) {\n  RegisterTexture(\n      std::make_shared<AndroidExternalTextureGL>(texture_id, surface_texture));\n}\n\n//texture.cc\nvoid TextureRegistry::RegisterTexture(std::shared_ptr<Texture> texture) {\n  mapping_[texture->Id()] = texture;\n}\n```\n\nFinally, the surfacetexture and id establish a mapping relationship and store it in the map of the TextureRegistry. When the subsequent TextureLayer executes the paint method, the surfacetexture will be taken out of the map and rendered.\nOverall flow chart:\n\n![image.png](http://sf1-vcloudcdn.pstatp.com/img/tos-cn-i-0000/4771b81175024a649fe4cb155b34babf~tplv-noop.png?width=1182\\&height=840)\n\n# IV. Examples\n\n```dart\n// Dart layer\nClass _MyHomePageState extends State < MyHomePage > {\nMethodChannel _channel= MethodChannel ('flutter.texture.demo ');\nInt _textureId= 0;\n\n@Override\nVoid initState () {\n_init ();\nSuper.initState ();\n}\n\n@Override\nWidget build (BuildContext context) {\nScaffold return return (\nAppBar: AppBar (\nText(widget.title),\n),\nBody: Column (\nmainAxisAlignment: MainAxisAlignment.start,\nWidget for children for children\nContainer (\n250, height height\nColor: Colors.blue,\nChild: Texture (textureId: _textureId),\n),\nFlatButton (\nonPressed: _draw,\nColor: Colors.blue,\nText (child: child:\n'Play '\n),\n)\n],\n) , // This trailing comma makes auto-formatting nicer for build methods.\n);\n}\n\nVoid _init () async {\n_textureId = await _channel.invokeMethod ('init');\nsetState (() {\n\n});\n}\n\nVoid _draw() {\n_channel invokeMethod ('play');\n}\n}\n\n//Java\n@Override\nPublic void onMethodCall (MethodCall methodCall, MethodChannel.Result result ) {\nSwitch (methodCall.method ) {\nIn case \"init\":\nTextureRegistry textureRegistry = mRegistrar.textures ();\nTextureRegistry.SurfaceTextureEntry entry = textureRegistry.createSurfaceTexture ();\nmSurface = new Surface (entry .surfaceTexture ());\ninitPlayer ();\nresult.success(entry.id ());\nTo return;\nThe case \"play\":\nPlay ();\nResult.success (null);\nTo return;\n}\nResult.notImplemented ();\n}\n\nPrivate void initPlayer () {\nmPlayer = new MediaPlayer ();\nTry {\nmPlayer.setDataSource (\"https: //clips.vorwaerts-gmbh.de/big_buck_bunny.mp4 \");\n} catch (IOException e) {\nE. printStackTrace ();\n}\nmPlayer.setSurface (mSurface);\n}\n\nPrivate void play () {\nTry {\nmPlayer.prepare ();\nmPlayer.start ();\n} catch (IOException e) {\nE. printStackTrace ();\n}\n}\n```\n\n[Final effect:](http://sf1-hscdn-tos.pstatp.com/obj/vcloud/3fdf48cc10cc65fa096d09704be313b7-.mp4)\n\n<p class=\"img-tip\" data-str=\"\"><img src=\"https://sf3-ttcdn-tos.pstatp.com/img/tos-cn-v-0000/ccb2333962134023a883155ed3f7dcfe~noop.png\" height=\"1884\" width=\"894\"/></p>\n",
"reviewed": 0,
"anonymous": 0,
"solve": 0,
"original": 0
},
"auther": {
"name": "黄铤",
"full_name": "黄铤",
"email": "huangting.byacht@bytedance.com",
"employee_id": 1000009077,
"lark_id": "6619088485317886216",
"avatar": "https://s3-fs.pstatp.com/static-resource/v1/da5a000aabe87f3412bc~?image_size=noop&cut_type=&quality=&format=png&sticker_format=.webp",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "5dgcb8d9",
"auth": 0,
"department_name": "产品研发和工程架构部-教育-PreK-客户端",
"intro": "",
"roleIds": [],
"score": 0,
"status": 1,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "890285e9074c0d08130c279110030de1",
"participate_time": 0,
"badge": {
"Activity": 0,
"ArticleAndVideo": 0,
"PointOfView": 0
},
"employee_type_v2": {
"id": 1,
"name": "正式",
"en_name": "Regular"
},
"department": {
"id": "288980000064977899",
"name": "产品研发和工程架构部-教育-PreK-客户端",
"en_name": "Product RD and Infrastructure-Education-PreK-Client"
},
"sequence_v2": {
"id": 9,
"name": "技术",
"en_name": "RD"
},
"en_name": "Ting Huang",
"leader": {
"id": 9290282,
"name": "杨坤",
"u_name": "杨坤 (yangkun.sitong)",
"email": "yangkun.sitong@bytedance.com",
"employee_number": 9290282,
"en_name": ""
},
"expert_category_ids": [],
"people_id": 1123991,
"entry_date": 1541116800
},
"category": {
"id": 3,
"name": "客户端",
"en_name": "Client",
"brief": "提供Android/iOS等平台上的App产品研发及线上运行保障。",
"logo": "",
"Ctime": 1567509556,
"Mtime": 1606450002,
"show_type": 3,
"is_show": 1,
"en_brief": "Provide the research and development and online operation guarantee for App products on platforms such as Android/iOS.",
"follow_count": 0,
"item_count": 0,
"is_follow": false
},
"labels": [
{
"id": 3,
"name": "Android",
"follow_count": 6774,
"item_count": 1105,
"en_name": "Android",
"icon": "",
"is_follow": false
}
],
"digg_infos": [],
"sticky_info": {
"is_sticky": false,
"auther": {
"name": "",
"full_name": "",
"email": "",
"employee_id": 0,
"lark_id": "",
"avatar": "",
"follow_count": 0,
"follower_count": 0,
"digg_cnt": 0,
"lark_open_id": "",
"auth": 0,
"department_name": "",
"intro": "",
"roleIds": null,
"score": 0,
"status": 0,
"answer_digg_cnt": 0,
"question_cnt": 0,
"answer_cnt": 0,
"is_follow": false,
"collect_cnt": 0,
"xid": "",
"participate_time": 0,
"badge": null,
"employee_type_v2": null,
"department": null,
"sequence_v2": null,
"en_name": "",
"leader": null,
"expert_category_ids": null,
"people_id": 0,
"entry_date": 0
}
},
"comment_info": {
"comments": null,
"cursor": "",
"HasMore": false
},
"highlight": {
"content": "因此，<em>Flutter</em>提供了一套外接纹理的机制来解决此类问题。...->obj(), <em>flutter</em>_jni_methods,\n                         fml::size(<em>flutter</em>_jni_methods)) !"
},
"is_digg": false,
"is_collect": false,
"visitor_answer_count": 0,
"id_type": 8,
"is_follow": false,
"is_author": false,
"is_digg_down": false,
"series_list": []
}
],
"cursor": "[52.906334,8442]",
"count": 289,
"has_more": true
}